{% extends "base.html" %}

{% block title %}Network Diagram - Traditional Network Map{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-12">
        <h1><i class="fas fa-project-diagram me-2"></i>Network Diagram</h1>
        <p class="text-muted">Traditional network diagram with device icons and structured layout</p>
    </div>
</div>

<div class="row mb-3">
    <!-- Main Network Diagram -->
    <div class="col-lg-8">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0"><i class="fas fa-network-wired me-2"></i>Network Infrastructure Diagram</h5>
                <div class="btn-toolbar" role="toolbar">
                    <!-- Primary Actions -->
                    <div class="btn-group btn-group-sm me-2" role="group">
                        <button class="btn btn-primary" onclick="refreshDiagram()" title="Refresh Diagram" id="refresh-btn">
                            <i class="fas fa-sync"></i> Refresh
                        </button>
                        <button class="btn btn-outline-primary" onclick="toggleConnectivityMode()" title="Analyze Connectivity Between Two Devices" id="connectivity-btn">
                            <i class="fas fa-sitemap"></i> <span id="connectivity-mode-text">Connectivity</span>
                        </button>
                    </div>

                    <!-- Navigation Tools -->
                    <div class="btn-group btn-group-sm me-2" role="group">
                        <button type="button" class="btn btn-outline-secondary dropdown-toggle" data-bs-toggle="dropdown" title="Navigation Tools">
                            <i class="fas fa-hand-paper"></i> Navigate
                        </button>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="#" onclick="toggleDragMode()"><i class="fas fa-arrows-alt me-2"></i><span id="drag-mode-text-dropdown">Enable Drag Mode</span></a></li>
                            <li><a class="dropdown-item" href="#" onclick="togglePanMode()"><i class="fas fa-hand-paper me-2"></i><span id="pan-mode-text-dropdown">Enable Pan Mode</span></a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="#" onclick="resetView()"><i class="fas fa-expand-arrows-alt me-2"></i>Reset View</a></li>
                        </ul>
                    </div>

                    <!-- Layout Tools -->
                    <div class="btn-group btn-group-sm me-2" role="group">
                        <button type="button" class="btn btn-outline-secondary dropdown-toggle" data-bs-toggle="dropdown" title="Layout Tools">
                            <i class="fas fa-cogs"></i> Layout
                        </button>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="#" onclick="saveLayout()" id="save-layout-dropdown"><i class="fas fa-save me-2"></i>Save Layout</a></li>
                            <li><a class="dropdown-item" href="#" onclick="resetLayout()"><i class="fas fa-undo me-2"></i>Reset Layout</a></li>
                        </ul>
                    </div>

                    <!-- Export & Info -->
                    <div class="btn-group btn-group-sm" role="group">
                        <button type="button" class="btn btn-outline-secondary dropdown-toggle" data-bs-toggle="dropdown" title="Export & Info">
                            <i class="fas fa-ellipsis-h"></i> More
                        </button>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="#" onclick="exportDiagram()"><i class="fas fa-download me-2"></i>Export as SVG</a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="#" onclick="showDiagramLegend()"><i class="fas fa-info-circle me-2"></i>Show Legend</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="card-body">
                <!-- Network Diagram Container -->
                <div id="network-diagram-container" style="height: 700px; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 0.375rem; position: relative; overflow: auto;">
                    <div class="loading-overlay" id="loading-overlay" style="display: none;">
                        <div class="d-flex flex-column align-items-center justify-content-center h-100">
                            <div class="spinner-border text-primary mb-3" role="status"></div>
                            <div class="text-primary">Generating network diagram...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Device Details Panel (right side) -->
    <div class="col-lg-4">
        <div class="card" style="height: 784px;"> <!-- Match diagram height + header -->
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-info-circle me-2"></i>Device Details
                </h6>
            </div>
            <div class="card-body" style="overflow-y: auto;">
                <div id="device-info-cards">
                    <div class="text-center text-muted">
                        <i class="fas fa-mouse-pointer fa-3x mb-3 text-secondary"></i>
                        <p>Click on a device in the diagram to view details</p>
                        <small class="text-muted">Device information will appear here when selected</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Legend Modal -->
<div class="modal fade" id="diagramLegendModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Network Diagram Legend</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="row">
                    <div class="col-12 mb-3">
                        <h6>Device Types</h6>
                        <div class="d-flex align-items-center mb-2">
                            <i class="fas fa-server text-primary fa-2x me-3"></i>
                            <span>Servers - Physical and virtual servers</span>
                        </div>
                        <div class="d-flex align-items-center mb-2">
                            <i class="fas fa-route text-warning fa-2x me-3"></i>
                            <span>Routers - Network routing devices</span>
                        </div>
                        <div class="d-flex align-items-center mb-2">
                            <i class="fas fa-network-wired text-info fa-2x me-3"></i>
                            <span>Switches - Network switching devices</span>
                        </div>
                        <div class="d-flex align-items-center mb-2">
                            <i class="fas fa-cloud text-secondary fa-2x me-3"></i>
                            <span>Cloud - Cloud services and external resources</span>
                        </div>
                        <div class="d-flex align-items-center mb-2">
                            <i class="fas fa-shield-alt text-success fa-2x me-3"></i>
                            <span>VPN - VPN endpoints and tunnels</span>
                        </div>
                        <div class="d-flex align-items-center mb-2">
                            <i class="fas fa-desktop text-success fa-2x me-3"></i>
                            <span>Workstations - Client computers</span>
                        </div>
                    </div>
                    <div class="col-12">
                        <h6>Connection Types</h6>
                        <div class="mb-2">
                            <svg width="40" height="10">
                                <line x1="0" y1="5" x2="40" y2="5" stroke="#007bff" stroke-width="3"/>
                            </svg>
                            <span class="ms-2">Primary network connections</span>
                        </div>
                        <div class="mb-2">
                            <svg width="40" height="10">
                                <line x1="0" y1="5" x2="40" y2="5" stroke="#6c757d" stroke-width="2" stroke-dasharray="5,5"/>
                            </svg>
                            <span class="ms-2">VPN connections</span>
                        </div>
                        <div class="mb-2">
                            <svg width="40" height="10">
                                <line x1="0" y1="5" x2="40" y2="5" stroke="#28a745" stroke-width="2"/>
                            </svg>
                            <span class="ms-2">Inter-VLAN connections</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
</div>
</div>

<!-- Device Edit Modal -->
<div class="modal fade" id="deviceEditModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Edit Device</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="deviceEditForm">
                    <input type="hidden" id="editDeviceId" value="">
                    
                    <div class="mb-3">
                        <label for="editDeviceName" class="form-label">Device Name</label>
                        <input type="text" class="form-control" id="editDeviceName" placeholder="Enter device name">
                        <div class="form-text">This will be displayed as the device label in the diagram</div>
                    </div>
                    
                    <div class="mb-3">
                        <label for="editDeviceType" class="form-label">Device Type</label>
                        <select class="form-select" id="editDeviceType">
                            <option value="server">üñ•Ô∏è Server - Physical and virtual servers</option>
                            <option value="router">üì° Router - Network routing devices</option>
                            <option value="switch">üîó Switch - Network switching devices</option>
                            <option value="cloud">‚òÅÔ∏è Cloud - Cloud services and external resources</option>
                            <option value="vpn">üõ°Ô∏è VPN - VPN endpoints and tunnels</option>
                            <option value="workstation">üíª Workstation - Client computers</option>
                            <option value="firewall">üî• Firewall - Network security devices</option>
                            <option value="gateway">üö™ Gateway - Network gateway devices</option>
                        </select>
                        <div class="form-text">This determines the icon shown in the diagram</div>
                    </div>
                    
                    <div class="mb-3">
                        <label for="editDeviceNotes" class="form-label">Notes</label>
                        <textarea class="form-control" id="editDeviceNotes" rows="3" placeholder="Add any notes about this device..."></textarea>
                        <div class="form-text">Optional notes about this device</div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="saveDeviceChanges()">Save Changes</button>
            </div>
        </div>
    </div>
</div>

<style>
.loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.9);
    z-index: 1000;
    border-radius: 0.375rem;
}

.device-icon {
    cursor: pointer;
    transition: filter 0.2s ease;
}

.device-icon:hover {
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
}

.device-icon.dragging {
    filter: drop-shadow(0 6px 12px rgba(0,0,0,0.4));
    transform: scale(1.05);
}

.device-selected {
    filter: drop-shadow(0 0 8px #007bff);
}

.device-connectivity-selected {
    filter: drop-shadow(0 0 12px #dc3545);
    animation: pulse-connectivity 1.5s ease-in-out infinite;
}

@keyframes pulse-connectivity {
    0% { filter: drop-shadow(0 0 12px #dc3545); }
    50% { filter: drop-shadow(0 0 20px #fd7e14); }
    100% { filter: drop-shadow(0 0 12px #dc3545); }
}

.connectivity-analysis-line {
    stroke: #dc3545;
    stroke-width: 4;
    stroke-dasharray: 10,5;
    fill: none;
    animation: dash-connectivity 2s linear infinite;
}

@keyframes dash-connectivity {
    to { stroke-dashoffset: -30; }
}

.network-segment {
    fill: rgba(0, 123, 255, 0.1);
    stroke: rgba(0, 123, 255, 0.3);
    stroke-width: 2;
    stroke-dasharray: 10,5;
}

.connection-line {
    stroke: #007bff;
    stroke-width: 2;
    fill: none;
}

.vpn-connection {
    stroke: #6c757d;
    stroke-width: 2;
    stroke-dasharray: 8,4;
    fill: none;
}

.vlan-connection {
    stroke: #28a745;
    stroke-width: 2;
    fill: none;
}

.device-label {
    font-family: Arial, sans-serif;
    font-size: 12px;
    font-weight: bold;
    text-anchor: middle;
    fill: #333;
    user-select: none;
}

.segment-label {
    font-family: Arial, sans-serif;
    font-size: 14px;
    font-weight: bold;
    text-anchor: middle;
    fill: #007bff;
    user-select: none;
}

.tooltip-box {
    position: absolute;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    z-index: 1000;
    max-width: 250px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
</style>
{% endblock %}

{% block scripts %}
<script>
// Network Diagram Implementation
let diagramData = null;
let selectedDevice = null;
let selectedDevices = []; // Array to track multiple selected devices
let connectivityMode = false; // Mode for analyzing connectivity between devices
let isDragMode = false;
let draggedDevice = null;
let networkStructure = null;
let customLayout = null;
let hasCustomChanges = false;

// Drag and drop state
let dragState = {
    isDragging: false,
    startX: 0,
    startY: 0,
    element: null,
    deviceId: null
};

// Pan state for view navigation
let panState = {
    isPanning: false,
    startX: 0,
    startY: 0,
    viewBoxX: 0,
    viewBoxY: 0,
    viewBoxWidth: 800,
    viewBoxHeight: 700
};

// Device icon mapping
const deviceIcons = {
    server: { icon: 'fas fa-server', color: '#007bff', size: 48 },
    router: { icon: 'fas fa-route', color: '#fd7e14', size: 48 },
    switch: { icon: 'fas fa-network-wired', color: '#17a2b8', size: 48 },
    gateway: { icon: 'fas fa-door-open', color: '#fd7e14', size: 48 },
    cloud: { icon: 'fas fa-cloud', color: '#6c757d', size: 48 },
    vpn: { icon: 'fas fa-shield-alt', color: '#28a745', size: 48 },
    workstation: { icon: 'fas fa-desktop', color: '#28a745', size: 42 },
    internet: { icon: 'fas fa-globe', color: '#17a2b8', size: 48 },
    firewall: { icon: 'fas fa-shield-alt', color: '#dc3545', size: 48 }
};

// Initialize diagram
function initializeNetworkDiagram() {
    console.log('Initializing Network Diagram...');
    refreshDiagram();
}

// Refresh diagram data and redraw
function refreshDiagram() {
    const refreshBtn = document.getElementById('refresh-btn');
    const loadingOverlay = document.getElementById('loading-overlay');
    
    // Show loading
    if (refreshBtn) {
        refreshBtn.disabled = true;
        refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    }
    if (loadingOverlay) {
        loadingOverlay.style.display = 'flex';
    }
    
    // Fetch network data
    fetch('/api/enhanced_network_data')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.topology) {
                diagramData = data.topology;
                generateNetworkDiagram();
            } else {
                throw new Error(data.error || 'Failed to load data');
            }
        })
        .catch(error => {
            console.error('Error loading data:', error);
            // Fallback to basic data
            return fetch('/api/network_data');
        })
        .then(response => {
            if (response) {
                return response.json();
            }
            return null;
        })
        .then(data => {
            if (data) {
                diagramData = convertBasicToEnhanced(data);
                generateNetworkDiagram();
            }
        })
        .catch(error => {
            console.error('Error loading fallback data:', error);
            showError('Failed to load network data');
        })
        .finally(() => {
            // Hide loading
            if (refreshBtn) {
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = '<i class="fas fa-sync"></i>';
            }
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
        });
}

// Convert basic data to enhanced format
function convertBasicToEnhanced(data) {
    const enhanced = {
        nodes: [],
        edges: []
    };
    
    // Convert nodes
    if (data.nodes) {
        enhanced.nodes = data.nodes.map(node => ({
            id: node.id,
            label: node.label || node.ip || 'Unknown',
            ip: node.ip,
            type: node.type || 'server',
            status: node.status || 'unknown',
            connections: 0
        }));
    }
    
    // Convert edges
    if (data.edges) {
        enhanced.edges = data.edges.map(edge => ({
            id: `${edge.from}-${edge.to}`,
            from: edge.from,
            to: edge.to,
            protocol: edge.protocol || 'tcp',
            port: edge.port,
            weight: edge.count || 1
        }));
    }
    
    return enhanced;
}

// Generate the network diagram
function generateNetworkDiagram() {
    if (!diagramData || !diagramData.nodes) return;
    
    const container = document.getElementById('network-diagram-container');
    const width = container.clientWidth;
    const height = container.clientHeight || 700;
    
    // Clear existing diagram
    container.innerHTML = '';
    
    // Create SVG
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    svg.style.background = '#f8f9fa';
    
    // Analyze network structure
    const networkStructure = analyzeNetworkStructure(diagramData, width, height);
    
    // Draw network segments
    drawNetworkSegments(svg, networkStructure, width, height);
    
    // Draw connections
    drawConnections(svg, networkStructure);
    
    // Draw devices
    drawDevices(svg, networkStructure);
    
    // Add to container
    container.appendChild(svg);
    
    console.log('Network diagram generated successfully');
}

// Analyze network structure to determine layout
function analyzeNetworkStructure(data, width, height) {
    const structure = {
        segments: {},
        devices: {},
        connections: []
    };
    
    // Group devices by network segment (based on IP ranges)
    data.nodes.forEach(node => {
        const segment = getNetworkSegment(node.ip);
        
        if (!structure.segments[segment]) {
            structure.segments[segment] = {
                name: segment,
                devices: [],
                type: 'lan'
            };
        }
        
        // Classify device type
        const deviceType = classifyDevice(node);
        
        structure.devices[node.id] = {
            ...node,
            deviceType: deviceType,
            segment: segment
        };
        
        structure.segments[segment].devices.push(node.id);
    });
    
    // Process connections
    if (data.edges) {
        data.edges.forEach(edge => {
            const fromDevice = structure.devices[edge.from];
            const toDevice = structure.devices[edge.to];
            
            if (fromDevice && toDevice) {
                structure.connections.push({
                    from: edge.from,
                    to: edge.to,
                    type: getConnectionType(fromDevice, toDevice),
                    protocol: edge.protocol || 'tcp'
                });
            }
        });
    }
    
    // Layout devices
    layoutDevices(structure, width, height);
    
    return structure;
}

// Get network segment from IP
function getNetworkSegment(ip) {
    if (!ip) return 'unknown';
    
    const parts = ip.split('.');
    if (parts.length >= 1) {
        const firstOctet = parts[0];
        
        // Group all 100.x.x.x networks as single 100.0.0.0/8 LAN
        if (firstOctet === '100') {
            return '100.0.0.0/8 LAN';
        }
        
        // Group other common private networks
        if (firstOctet === '192' && parts[1] === '168') {
            return '192.168.0.0/16 LAN';
        }
        
        if (firstOctet === '10') {
            return '10.0.0.0/8 LAN';
        }
        
        if (firstOctet === '172' && parts.length >= 2) {
            const secondOctet = parseInt(parts[1]);
            if (secondOctet >= 16 && secondOctet <= 31) {
                return '172.16.0.0/12 LAN';
            }
        }
    }
    
    if (ip.includes('::') || ip.includes(':')) {
        return 'IPv6';
    }
    
    return 'External';
}

// Classify device based on characteristics
function classifyDevice(node) {
    const type = node.type?.toLowerCase() || '';
    const label = node.label?.toLowerCase() || '';
    const ip = node.ip || '';
    
    // Check for specific device types
    if (type.includes('router') || label.includes('router') || label.includes('gateway')) {
        return 'router';
    }
    if (type.includes('switch') || label.includes('switch')) {
        return 'switch';
    }
    if (type.includes('firewall') || label.includes('firewall')) {
        return 'firewall';
    }
    if (type.includes('vpn') || label.includes('vpn')) {
        return 'vpn';
    }
    if (type.includes('cloud') || ip.includes('amazonaws') || ip.includes('azure') || ip.includes('google')) {
        return 'cloud';
    }
    if (type.includes('workstation') || type.includes('desktop') || type.includes('laptop')) {
        return 'workstation';
    }
    if (type.includes('internet') || !ip.includes('192.168.') && !ip.includes('10.') && !ip.includes('172.')) {
        return 'internet';
    }
    
    // Default to server
    return 'server';
}

// Determine connection type
function getConnectionType(fromDevice, toDevice) {
    if (fromDevice.deviceType === 'vpn' || toDevice.deviceType === 'vpn') {
        return 'vpn';
    }
    
    if (fromDevice.segment !== toDevice.segment) {
        return 'inter-segment';
    }
    
    return 'standard';
}

// Layout devices in segments with clean, hierarchical structure
function layoutDevices(structure, width, height) {
    const segments = Object.keys(structure.segments);
    const margin = 40;
    
    // Set global boundaries for proper constraint enforcement
    structure.globalBounds = {
        x: 0,
        y: 0,
        width: width,
        height: height
    };
    
    // Prioritize segment types for better organization
    const segmentPriority = {
        '100.0.0.0/8 LAN': 1,
        '192.168.0.0/16 LAN': 2,
        '10.0.0.0/8 LAN': 3,
        '172.16.0.0/12 LAN': 4,
        'External': 5,
        'IPv6': 6,
        'unknown': 7
    };
    
    // Sort segments by priority
    segments.sort((a, b) => (segmentPriority[a] || 99) - (segmentPriority[b] || 99));
    
    // Use hierarchical layout: Core/LAN networks on left, External on right
    const lanSegments = segments.filter(s => s.includes('LAN') || s === 'unknown');
    const externalSegments = segments.filter(s => s === 'External');
    const ipv6Segments = segments.filter(s => s === 'IPv6');
    
    const allOrderedSegments = [...lanSegments, ...ipv6Segments, ...externalSegments];
    
    // Calculate layout zones
    const segmentSpacing = 30;
    const availableWidth = width - (2 * margin);
    const availableHeight = height - (2 * margin);
    
    // Determine layout strategy based on number of segments
    if (allOrderedSegments.length === 1) {
        // Single segment - use most of the space
        layoutSingleSegment(structure, allOrderedSegments[0], margin, margin, 
                           availableWidth, availableHeight);
    } else if (allOrderedSegments.length === 2) {
        // Two segments - side by side
        const segmentWidth = (availableWidth - segmentSpacing) / 2;
        layoutSingleSegment(structure, allOrderedSegments[0], margin, margin, 
                           segmentWidth, availableHeight);
        layoutSingleSegment(structure, allOrderedSegments[1], margin + segmentWidth + segmentSpacing, 
                           margin, segmentWidth, availableHeight);
    } else {
        // Multiple segments - use grid but prioritize important ones
        const rows = Math.ceil(allOrderedSegments.length / 2);
        const segmentWidth = (availableWidth - segmentSpacing) / 2;
        const segmentHeight = (availableHeight - ((rows - 1) * segmentSpacing)) / rows;
        
        allOrderedSegments.forEach((segmentName, index) => {
            const row = Math.floor(index / 2);
            const col = index % 2;
            
            const x = margin + col * (segmentWidth + segmentSpacing);
            const y = margin + row * (segmentHeight + segmentSpacing);
            
            layoutSingleSegment(structure, segmentName, x, y, segmentWidth, segmentHeight);
        });
    }
}

// Layout a single network segment with clean device organization
function layoutSingleSegment(structure, segmentName, x, y, width, height) {
    const segment = structure.segments[segmentName];
    if (!segment) return;
    
    const deviceMargin = 30;
    const labelHeight = 30;
    const availableWidth = width - (2 * deviceMargin);
    
    // Organize devices by type for better visual hierarchy
    const devicesByType = {
        router: [],
        switch: [],
        firewall: [],
        server: [],
        workstation: [],
        cloud: [],
        vpn: [],
        internet: [],
        gateway: []
    };
    
    // Categorize devices
    segment.devices.forEach(deviceId => {
        const device = structure.devices[deviceId];
        const type = device.deviceType || 'server';
        if (devicesByType[type]) {
            devicesByType[type].push(deviceId);
        } else {
            devicesByType.server.push(deviceId);
        }
    });
    
    // Layout devices in organized rows by type
    let currentY = y + labelHeight + 15;
    const deviceSize = 50;
    const deviceSpacing = 80; // Normal spacing for better layout
    
    // Calculate devices per row based on available width
    const maxDevicesPerRow = Math.max(1, Math.floor(availableWidth / deviceSpacing));
    
    // Process each device type
    Object.entries(devicesByType).forEach(([type, devices]) => {
        if (devices.length === 0) return;
        
        // Layout devices of this type
        devices.forEach((deviceId, index) => {
            const device = structure.devices[deviceId];
            const row = Math.floor(index / maxDevicesPerRow);
            const col = index % maxDevicesPerRow;
            
            // Center devices in each row
            const devicesInThisRow = Math.min(maxDevicesPerRow, devices.length - row * maxDevicesPerRow);
            const rowWidth = (devicesInThisRow - 1) * deviceSpacing;
            const startX = x + deviceMargin + (availableWidth - rowWidth) / 2;
            
            device.x = startX + col * deviceSpacing;
            device.y = currentY + row * (deviceSize + 20);
            
            // NO boundary constraints - let devices be positioned freely
            // The SVG will be resized to accommodate all devices
        });
        
        // Move to next section for next device type
        const rowsUsed = Math.ceil(devices.length / maxDevicesPerRow);
        currentY += rowsUsed * (deviceSize + 20) + 15;
    });
    
    // Store segment layout info
    segment.bounds = {
        x: x,
        y: y,
        width: width,
        height: height
    };
}

// Draw network segments
function drawNetworkSegments(svg, structure, width, height) {
    // Network segment rectangles and labels are now hidden for cleaner appearance
    // The segment grouping logic is still used for device organization and connections
}

// Draw connections between devices with smart routing
function drawConnections(svg, structure) {
    // Group connections to avoid visual clutter
    const connectionGroups = {};
    const drawnConnections = new Set();
    
    structure.connections.forEach(connection => {
        const fromDevice = structure.devices[connection.from];
        const toDevice = structure.devices[connection.to];
        
        if (!fromDevice || !toDevice || !fromDevice.x || !toDevice.x) return;
        
        // Create unique connection key (bidirectional)
        const connectionKey = [connection.from, connection.to].sort().join('-');
        if (drawnConnections.has(connectionKey)) return;
        drawnConnections.add(connectionKey);
        
        // Only draw meaningful connections
        const shouldDrawConnection = shouldShowConnection(fromDevice, toDevice, structure);
        if (!shouldDrawConnection) return;
        
        // Draw clean, curved connections for better visualization
        drawCleanConnection(svg, fromDevice, toDevice, connection.type);
    });
}

// Determine if a connection should be shown to reduce clutter
function shouldShowConnection(fromDevice, toDevice, structure) {
    // Always show inter-segment connections
    if (fromDevice.segment !== toDevice.segment) {
        return true;
    }
    
    // Show connections involving network infrastructure devices
    const infrastructureTypes = ['router', 'switch', 'firewall', 'gateway'];
    if (infrastructureTypes.includes(fromDevice.deviceType) || 
        infrastructureTypes.includes(toDevice.deviceType)) {
        return true;
    }
    
    // Show VPN connections
    if (fromDevice.deviceType === 'vpn' || toDevice.deviceType === 'vpn') {
        return true;
    }
    
    // Show connections to external/cloud services
    if (fromDevice.segment === 'External' || toDevice.segment === 'External') {
        return true;
    }
    
    // Limit server-to-server connections within same segment
    return false;
}

// Draw a clean, optionally curved connection
function drawCleanConnection(svg, fromDevice, toDevice, connectionType) {
    const x1 = fromDevice.x;
    const y1 = fromDevice.y;
    const x2 = toDevice.x;
    const y2 = toDevice.y;
    
    // Calculate if we need a curved connection (for long distances or different segments)
    const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    const useCurve = distance > 200 || fromDevice.segment !== toDevice.segment;
    
    if (useCurve && fromDevice.segment !== toDevice.segment) {
        // Draw curved path for inter-segment connections
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        
        // Calculate control points for smooth curve
        const midX = (x1 + x2) / 2;
        const midY = (y1 + y2) / 2;
        const offsetY = -50; // Curve upward for better visibility
        
        const pathData = `M ${x1} ${y1} Q ${midX} ${midY + offsetY} ${x2} ${y2}`;
        path.setAttribute('d', pathData);
        path.setAttribute('fill', 'none');
        
        // Style based on connection type
        switch (connectionType) {
            case 'vpn':
                path.setAttribute('class', 'vpn-connection');
                break;
            case 'inter-segment':
                path.setAttribute('class', 'vlan-connection');
                break;
            default:
                path.setAttribute('class', 'connection-line');
        }
        
        svg.appendChild(path);
    } else {
        // Draw straight line for simple connections
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        
        // Style based on connection type
        switch (connectionType) {
            case 'vpn':
                line.setAttribute('class', 'vpn-connection');
                break;
            case 'inter-segment':
                line.setAttribute('class', 'vlan-connection');
                break;
            default:
                line.setAttribute('class', 'connection-line');
        }
        
        svg.appendChild(line);
    }
}

// Draw devices with icons
function drawDevices(svg, structure) {
    Object.values(structure.devices).forEach(device => {
        if (device.x && device.y) {
            const deviceConfig = deviceIcons[device.deviceType] || deviceIcons.server;
            
            // Create device group
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', 'device-icon');
            group.setAttribute('data-device-id', device.id);
            
            // Device background circle
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', device.x);
            circle.setAttribute('cy', device.y);
            circle.setAttribute('r', deviceConfig.size / 2 + 5);
            circle.setAttribute('fill', 'white');
            circle.setAttribute('stroke', deviceConfig.color);
            circle.setAttribute('stroke-width', '3');
            group.appendChild(circle);
            
            // Device icon (using FontAwesome classes converted to SVG paths would be complex,
            // so we'll use Unicode symbols or simple shapes for now)
            const iconText = getDeviceIconSymbol(device.deviceType);
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', device.x);
            text.setAttribute('y', device.y + 8);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', '24');
            text.setAttribute('fill', deviceConfig.color);
            text.setAttribute('font-family', 'Arial, sans-serif');
            text.textContent = iconText;
            group.appendChild(text);
            
            // Device label
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', device.x);
            label.setAttribute('y', device.y + deviceConfig.size / 2 + 20);
            label.setAttribute('class', 'device-label');
            label.textContent = device.label || device.ip;
            group.appendChild(label);
            
            // Add click event
            group.addEventListener('click', () => selectDevice(device));
            group.addEventListener('mouseenter', (e) => showTooltip(e, device));
            group.addEventListener('mouseleave', hideTooltip);
            
            svg.appendChild(group);
        }
    });
}

// Get Unicode symbol for device type
function getDeviceIconSymbol(deviceType) {
    const symbols = {
        server: 'üñ•Ô∏è',
        router: 'üì°',
        switch: 'üîó',
        gateway: 'üö™',
        cloud: '‚òÅÔ∏è',
        vpn: 'üõ°Ô∏è',
        workstation: 'üíª',
        internet: 'üåê',
        firewall: 'üî•'
    };
    
    return symbols[deviceType] || 'üìü';
}

// Select device and show details
function selectDevice(device) {
    selectedDevice = device;
    
    // Update visual selection
    document.querySelectorAll('.device-icon').forEach(el => {
        el.classList.remove('device-selected');
    });
    
    document.querySelector(`[data-device-id="${device.id}"]`).classList.add('device-selected');
    
    // Show device details
    showDeviceDetails(device);
}

// Show device details in panel
function showDeviceDetails(device) {
    const deviceInfoCards = document.getElementById('device-info-cards');
    
    const deviceConfig = deviceIcons[device.deviceType] || deviceIcons.server;
    
    // Get connection details for this device
    const connectionDetails = getDeviceConnections(device.id);
    
    deviceInfoCards.innerHTML = `
        <div class="card border-primary mb-3">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h6 class="mb-0">
                    <i class="${deviceConfig.icon} me-2"></i>${device.label || device.ip}
                </h6>
                <button class="btn btn-light btn-sm" onclick="openDeviceEditModal('${device.id}')" title="Edit Device">
                    <i class="fas fa-edit"></i>
                </button>
            </div>
            <div class="card-body">
                <div class="mb-2"><strong>IP Address:</strong><br><code class="text-primary">${device.ip}</code></div>
                <div class="mb-2"><strong>Device Type:</strong><br><span class="text-capitalize">${device.deviceType}</span></div>
                <div class="mb-2"><strong>Status:</strong><br>
                    <span class="badge bg-${getStatusColor(device.status)}">${device.status}</span>
                </div>
                <div class="mb-2"><strong>Network Segment:</strong><br><small class="text-muted">${device.segment}</small></div>
                ${device.hostname ? `<div class="mb-2"><strong>Hostname:</strong><br>${device.hostname}</div>` : ''}
            </div>
        </div>
        
        <!-- Connection Information -->
        <div class="card border-info mb-3">
            <div class="card-header bg-info text-white">
                <h6 class="mb-0"><i class="fas fa-network-wired me-2"></i>Network Connections (${connectionDetails.length})</h6>
            </div>
            <div class="card-body">
                ${generateConnectionsHTML(connectionDetails, device.id)}
            </div>
        </div>
        
        <!-- Additional Info -->
        <div class="card border-secondary">
            <div class="card-header bg-secondary text-white">
                <h6 class="mb-0"><i class="fas fa-cog me-2"></i>Additional Information</h6>
            </div>
            <div class="card-body">
                <div class="small text-muted">
                    <div class="mb-2"><strong>Device ID:</strong> ${device.id}</div>
                    <div class="mb-2"><strong>Position:</strong> ${Math.round(device.x)}, ${Math.round(device.y)}</div>
                    ${device.type ? `<div class="mb-2"><strong>Original Type:</strong> ${device.type}</div>` : ''}
                </div>
            </div>
        </div>
    `;
}

// Get all connections for a specific device
function getDeviceConnections(deviceId) {
    if (!networkStructure || !networkStructure.connections) return [];
    
    const connections = [];
    
    networkStructure.connections.forEach(connection => {
        if (connection.from === deviceId || connection.to === deviceId) {
            // Determine the connected device (the "other" device)
            const connectedDeviceId = connection.from === deviceId ? connection.to : connection.from;
            const connectedDevice = networkStructure.devices[connectedDeviceId];
            
            if (connectedDevice) {
                connections.push({
                    ...connection,
                    connectedDevice: connectedDevice,
                    direction: connection.from === deviceId ? 'outgoing' : 'incoming',
                    isLocal: connectedDevice.segment === networkStructure.devices[deviceId].segment
                });
            }
        }
    });
    
    return connections;
}

// Generate HTML for connections display
function generateConnectionsHTML(connections, deviceId) {
    if (connections.length === 0) {
        return `
            <div class="text-center text-muted">
                <i class="fas fa-unlink fa-2x mb-2"></i>
                <p class="small mb-0">No network connections found</p>
                <small class="text-muted">This device appears to be isolated or connections are not detected</small>
            </div>
        `;
    }
    
    // Group connections by type
    const localConnections = connections.filter(conn => conn.isLocal);
    const remoteConnections = connections.filter(conn => !conn.isLocal);
    const vpnConnections = connections.filter(conn => conn.type === 'vpn');
    
    let html = '';
    
    // Local connections
    if (localConnections.length > 0) {
        html += `
            <div class="mb-3">
                <h6 class="text-success mb-2">
                    <i class="fas fa-home me-1"></i>Local Network Connections (${localConnections.length})
                </h6>
                <div class="connection-list">
        `;
        localConnections.forEach(conn => {
            html += generateConnectionItem(conn, 'success');
        });
        html += '</div></div>';
    }
    
    // Remote connections
    if (remoteConnections.length > 0 && vpnConnections.length === 0) {
        html += `
            <div class="mb-3">
                <h6 class="text-primary mb-2">
                    <i class="fas fa-globe me-1"></i>Remote Connections (${remoteConnections.length})
                </h6>
                <div class="connection-list">
        `;
        remoteConnections.forEach(conn => {
            html += generateConnectionItem(conn, 'primary');
        });
        html += '</div></div>';
    }
    
    // VPN connections
    if (vpnConnections.length > 0) {
        html += `
            <div class="mb-3">
                <h6 class="text-warning mb-2">
                    <i class="fas fa-shield-alt me-1"></i>VPN Connections (${vpnConnections.length})
                </h6>
                <div class="connection-list">
        `;
        vpnConnections.forEach(conn => {
            html += generateConnectionItem(conn, 'warning');
        });
        html += '</div></div>';
    }
    
    // Connection summary
    html += `
        <div class="border-top pt-2 mt-3">
            <small class="text-muted">
                <i class="fas fa-info-circle me-1"></i>
                Total: ${connections.length} connection${connections.length !== 1 ? 's' : ''} ‚Ä¢ 
                Local: ${localConnections.length} ‚Ä¢ 
                Remote: ${remoteConnections.length} ‚Ä¢ 
                VPN: ${vpnConnections.length}
            </small>
        </div>
    `;
    
    return html;
}

// Generate HTML for individual connection item
function generateConnectionItem(connection, badgeColor) {
    const device = connection.connectedDevice;
    const deviceConfig = deviceIcons[device.deviceType] || deviceIcons.server;
    
    // Determine connection icon and description
    let connectionIcon = 'fas fa-link';
    let connectionDesc = 'Standard';
    
    switch (connection.type) {
        case 'vpn':
            connectionIcon = 'fas fa-shield-alt';
            connectionDesc = 'VPN';
            break;
        case 'inter-segment':
            connectionIcon = 'fas fa-route';
            connectionDesc = 'Inter-Network';
            break;
        default:
            connectionIcon = 'fas fa-link';
            connectionDesc = 'Direct';
    }
    
    return `
        <div class="connection-item d-flex align-items-center mb-2 p-2 border border-${badgeColor} rounded bg-light">
            <div class="me-2">
                <i class="${deviceConfig.icon} text-${deviceConfig.color.replace('#', '')} fa-lg"></i>
            </div>
            <div class="flex-grow-1">
                <div class="fw-bold text-truncate" style="max-width: 200px;" title="${device.label || device.ip}">
                    ${device.label || device.ip}
                </div>
                <div class="small text-muted">
                    <code class="small">${device.ip}</code> ‚Ä¢ 
                    <span class="text-capitalize">${device.deviceType}</span>
                    ${device.segment !== networkStructure.devices[Object.keys(networkStructure.devices).find(id => networkStructure.devices[id] === device)].segment ? 
                        ' ‚Ä¢ <span class="text-warning">Different Network</span>' : ''}
                </div>
                <div class="small">
                    <i class="${connectionIcon} me-1"></i>${connectionDesc}
                    ${connection.protocol ? ` ‚Ä¢ ${connection.protocol.toUpperCase()}` : ''}
                    ${connection.direction === 'outgoing' ? 
                        '<i class="fas fa-arrow-right text-success ms-1" title="Outgoing"></i>' : 
                        '<i class="fas fa-arrow-left text-info ms-1" title="Incoming"></i>'}
                </div>
            </div>
            <div class="text-end">
                <span class="badge bg-${badgeColor} small">${device.segment}</span>
            </div>
        </div>
    `;
}

// Show tooltip
function showTooltip(event, device) {
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip-box';
    tooltip.innerHTML = `
        <strong>${device.label || device.ip}</strong><br>
        Type: ${device.deviceType}<br>
        Status: ${device.status}<br>
        Network: ${device.segment}
    `;
    
    tooltip.style.left = event.pageX + 10 + 'px';
    tooltip.style.top = event.pageY - 10 + 'px';
    
    document.body.appendChild(tooltip);
    
    // Store reference for removal
    event.target.tooltip = tooltip;
}

// Hide tooltip
function hideTooltip(event) {
    if (event.target.tooltip) {
        document.body.removeChild(event.target.tooltip);
        event.target.tooltip = null;
    }
}

// Export diagram as SVG
function exportDiagram() {
    const svg = document.querySelector('#network-diagram-container svg');
    if (!svg) return;
    
    const svgData = new XMLSerializer().serializeToString(svg);
    const svgBlob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
    const svgUrl = URL.createObjectURL(svgBlob);
    
    const link = document.createElement('a');
    link.href = svgUrl;
    link.download = `network-diagram-${new Date().toISOString().split('T')[0]}.svg`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    URL.revokeObjectURL(svgUrl);
}

// Show legend modal
function showDiagramLegend() {
    const modal = new bootstrap.Modal(document.getElementById('diagramLegendModal'));
    modal.show();
}

// Show error message
function showError(message) {
    const container = document.getElementById('network-diagram-container');
    container.innerHTML = `
        <div class="alert alert-danger m-3">
            <i class="fas fa-exclamation-triangle me-2"></i>
            ${message}
        </div>
    `;
}

// Utility function for status colors
function getStatusColor(status) {
    const colors = {
        online: 'success',
        offline: 'danger',
        warning: 'warning',
        unknown: 'secondary'
    };
    return colors[status] || 'secondary';
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    initializeNetworkDiagram();
});

// Handle window resize
window.addEventListener('resize', function() {
    if (diagramData) {
        setTimeout(generateNetworkDiagram, 100);
    }
});

// ============================================
// PAN FUNCTIONALITY
// ============================================

let isPanMode = false;

// Toggle pan mode
function togglePanMode() {
    isPanMode = !isPanMode;
    
    // Update dropdown text
    const panModeTextDropdown = document.getElementById('pan-mode-text-dropdown');
    
    if (isPanMode) {
        panModeTextDropdown.textContent = 'Disable Pan Mode';
        
        // Disable drag mode if active
        if (isDragMode) {
            toggleDragMode();
        }
        
        // Enable panning
        enablePanning();
        
        showMessage('Pan mode enabled! Click and drag to navigate the view.', 'info');
    } else {
        panModeTextDropdown.textContent = 'Enable Pan Mode';
        
        // Disable panning
        disablePanning();
        
        showMessage('Pan mode disabled.', 'info');
    }
}

// Enable panning
function enablePanning() {
    const container = document.getElementById('network-diagram-container');
    container.style.cursor = 'grab';
    
    container.addEventListener('mousedown', startPan);
    document.addEventListener('mousemove', panView);
    document.addEventListener('mouseup', endPan);
    
    // Also add mouse wheel support for zooming/panning
    container.addEventListener('wheel', handleWheel, { passive: false });
}

// Disable panning
function disablePanning() {
    const container = document.getElementById('network-diagram-container');
    container.style.cursor = 'default';
    
    container.removeEventListener('mousedown', startPan);
    document.removeEventListener('mousemove', panView);
    document.removeEventListener('mouseup', endPan);
    container.removeEventListener('wheel', handleWheel);
}

// Start panning
function startPan(event) {
    if (!isPanMode) return;
    
    // Don't pan if clicking on a device
    if (event.target.closest('.device-icon')) return;
    
    event.preventDefault();
    
    const container = document.getElementById('network-diagram-container');
    container.style.cursor = 'grabbing';
    
    panState.isPanning = true;
    panState.startX = event.clientX;
    panState.startY = event.clientY;
    
    // Get current viewBox values
    const svg = document.querySelector('#network-diagram-container svg');
    const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
    panState.viewBoxX = viewBox[0];
    panState.viewBoxY = viewBox[1];
    panState.viewBoxWidth = viewBox[2];
    panState.viewBoxHeight = viewBox[3];
}

// Pan the view
function panView(event) {
    if (!panState.isPanning || !isPanMode) return;
    
    event.preventDefault();
    
    const deltaX = event.clientX - panState.startX;
    const deltaY = event.clientY - panState.startY;
    
    // Calculate new viewBox position (invert delta for natural panning)
    const newViewBoxX = panState.viewBoxX - deltaX;
    const newViewBoxY = panState.viewBoxY - deltaY;
    
    // Update viewBox
    const svg = document.querySelector('#network-diagram-container svg');
    svg.setAttribute('viewBox', `${newViewBoxX} ${newViewBoxY} ${panState.viewBoxWidth} ${panState.viewBoxHeight}`);
}

// End panning
function endPan(event) {
    if (!panState.isPanning) return;
    
    const container = document.getElementById('network-diagram-container');
    container.style.cursor = 'grab';
    
    panState.isPanning = false;
}

// Handle mouse wheel for zooming and panning
function handleWheel(event) {
    if (!isPanMode) return;
    
    event.preventDefault();
    
    const svg = document.querySelector('#network-diagram-container svg');
    const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
    let [x, y, width, height] = viewBox;
    
    if (event.ctrlKey || event.metaKey) {
        // Zoom with Ctrl/Cmd + wheel
        const zoomFactor = event.deltaY > 0 ? 1.1 : 0.9;
        const rect = svg.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        
        // Calculate mouse position in SVG coordinates
        const svgMouseX = x + (mouseX / rect.width) * width;
        const svgMouseY = y + (mouseY / rect.height) * height;
        
        // Calculate new dimensions
        const newWidth = width * zoomFactor;
        const newHeight = height * zoomFactor;
        
        // Adjust position to zoom towards mouse cursor
        const newX = svgMouseX - (svgMouseX - x) * zoomFactor;
        const newY = svgMouseY - (svgMouseY - y) * zoomFactor;
        
        svg.setAttribute('viewBox', `${newX} ${newY} ${newWidth} ${newHeight}`);
    } else {
        // Pan with regular wheel
        const panSpeed = 20;
        const newX = x + (event.deltaX * panSpeed / 100);
        const newY = y + (event.deltaY * panSpeed / 100);
        
        svg.setAttribute('viewBox', `${newX} ${newY} ${width} ${height}`);
    }
}

// Reset view to fit all devices
function resetView() {
    if (!networkStructure) return;
    
    const svg = document.querySelector('#network-diagram-container svg');
    if (!svg) return;
    
    // Find bounds of all devices
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    let deviceCount = 0;
    
    Object.values(networkStructure.devices).forEach(device => {
        if (device.x !== undefined && device.y !== undefined) {
            const deviceConfig = deviceIcons[device.deviceType] || deviceIcons.server;
            const radius = (deviceConfig.size / 2) + 30;
            
            minX = Math.min(minX, device.x - radius);
            minY = Math.min(minY, device.y - radius);
            maxX = Math.max(maxX, device.x + radius);
            maxY = Math.max(maxY, device.y + radius);
            deviceCount++;
        }
    });
    
    if (deviceCount === 0) return;
    
    // Add padding
    const padding = 50;
    minX = Math.max(0, minX - padding);
    minY = Math.max(0, minY - padding);
    maxX += padding;
    maxY += padding;
    
    const width = maxX - minX;
    const height = maxY - minY;
    
    // Set viewBox to show all devices
    svg.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
    
    showMessage('View reset to show all devices.', 'info');
}

// ============================================
// DRAG AND DROP FUNCTIONALITY
// ============================================

// Toggle drag mode
function toggleDragMode() {
    isDragMode = !isDragMode;
    const saveLayoutBtn = document.getElementById('save-layout-btn');
    const saveLayoutDropdown = document.getElementById('save-layout-dropdown');
    
    // Update dropdown text
    const dragModeTextDropdown = document.getElementById('drag-mode-text-dropdown');
    
    if (isDragMode) {
        dragModeTextDropdown.textContent = 'Disable Drag Mode';
        
        // Disable pan mode if active
        if (isPanMode) {
            togglePanMode();
        }
        
        // Enable dragging on all device icons
        enableDragging();
        
        // Show instructions
        showMessage('Drag mode enabled! Drag devices to reposition them.', 'info');
    } else {
        dragModeTextDropdown.textContent = 'Enable Drag Mode';
        
        // Disable dragging
        disableDragging();
        
        showMessage('Drag mode disabled.', 'info');
    }
    
    // Enable/disable save button based on custom changes
    if (saveLayoutBtn) saveLayoutBtn.disabled = !hasCustomChanges;
    if (saveLayoutDropdown) {
        if (hasCustomChanges) {
            saveLayoutDropdown.classList.remove('disabled');
        } else {
            saveLayoutDropdown.classList.add('disabled');
        }
    }
}

// Enable dragging on device icons
function enableDragging() {
    const deviceIcons = document.querySelectorAll('.device-icon');
    
    deviceIcons.forEach(icon => {
        icon.style.cursor = 'move';
        icon.addEventListener('mousedown', startDrag);
    });
    
    // Add global mouse event listeners
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', endDrag);
}

// Disable dragging
function disableDragging() {
    const deviceIcons = document.querySelectorAll('.device-icon');
    
    deviceIcons.forEach(icon => {
        icon.style.cursor = 'pointer';
        icon.removeEventListener('mousedown', startDrag);
    });
    
    // Remove global mouse event listeners
    document.removeEventListener('mousemove', drag);
    document.removeEventListener('mouseup', endDrag);
}

// Start dragging
function startDrag(event) {
    if (!isDragMode) return;
    
    event.preventDefault();
    event.stopPropagation();
    
    const deviceElement = event.currentTarget;
    const deviceId = deviceElement.getAttribute('data-device-id');
    
    // Get SVG coordinates
    const svg = document.querySelector('#network-diagram-container svg');
    const rect = svg.getBoundingClientRect();
    
    dragState.isDragging = true;
    dragState.element = deviceElement;
    dragState.deviceId = deviceId;
    dragState.startX = event.clientX - rect.left;
    dragState.startY = event.clientY - rect.top;
    
    // Visual feedback
    deviceElement.style.opacity = '0.7';
    deviceElement.style.transform = 'scale(1.1)';
    
    console.log(`Started dragging device ${deviceId}`);
}

// Drag the element
function drag(event) {
    if (!dragState.isDragging || !isDragMode) return;
    
    event.preventDefault();
    
    const svg = document.querySelector('#network-diagram-container svg');
    const rect = svg.getBoundingClientRect();
    
    const currentX = event.clientX - rect.left;
    const currentY = event.clientY - rect.top;
    
    // No boundary constraints - allow free positioning
    // The SVG will be dynamically resized to accommodate all devices
    
    // Update device position in the structure
    if (networkStructure && networkStructure.devices[dragState.deviceId]) {
        networkStructure.devices[dragState.deviceId].x = currentX;
        networkStructure.devices[dragState.deviceId].y = currentY;
        
        // Update visual position
        updateDeviceVisualPosition(dragState.deviceId, currentX, currentY);
        
        // Mark as having custom changes
        hasCustomChanges = true;
        
        // Update connections
        redrawConnections();
        
        // Dynamically resize SVG to accommodate all devices
        resizeSVGToFitDevices();
    }
}

// End dragging
function endDrag(event) {
    if (!dragState.isDragging) return;
    
    // Reset visual feedback
    if (dragState.element) {
        dragState.element.style.opacity = '1';
        dragState.element.style.transform = 'scale(1)';
    }
    
    // Reset drag state
    dragState.isDragging = false;
    dragState.element = null;
    dragState.deviceId = null;
    
    // Enable save button if we have custom changes
    if (hasCustomChanges) {
        document.getElementById('save-layout-btn').disabled = false;
    }
    
    console.log('Ended dragging');
}

// Update device visual position
function updateDeviceVisualPosition(deviceId, x, y) {
    const deviceElement = document.querySelector(`[data-device-id="${deviceId}"]`);
    if (!deviceElement) return;
    
    // Update all child elements (circle, text, label)
    const circle = deviceElement.querySelector('circle');
    const iconText = deviceElement.querySelector('text');
    const labels = deviceElement.querySelectorAll('text');
    
    if (circle) {
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
    }
    
    if (iconText) {
        iconText.setAttribute('x', x);
        iconText.setAttribute('y', y + 8);
    }
    
    // Update all text labels
    labels.forEach((label, index) => {
        label.setAttribute('x', x);
        if (index === 1) { // Device label (second text element)
            const deviceConfig = deviceIcons[networkStructure.devices[deviceId].deviceType] || deviceIcons.server;
            label.setAttribute('y', y + deviceConfig.size / 2 + 20);
        }
    });
}

// Redraw connections when devices move
function redrawConnections() {
    if (!networkStructure) return;
    
    // Remove existing connections
    const svg = document.querySelector('#network-diagram-container svg');
    const connections = svg.querySelectorAll('line, path');
    connections.forEach(conn => {
        if (conn.getAttribute('class')?.includes('connection')) {
            conn.remove();
        }
    });
    
    // Redraw connections
    drawConnections(svg, networkStructure);
}

// Resize SVG to fit all devices
function resizeSVGToFitDevices() {
    if (!networkStructure) return;
    
    const svg = document.querySelector('#network-diagram-container svg');
    if (!svg) return;
    
    // Find the bounding box of all devices
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    let deviceCount = 0;
    
    Object.values(networkStructure.devices).forEach(device => {
        if (device.x !== undefined && device.y !== undefined) {
            const deviceConfig = deviceIcons[device.deviceType] || deviceIcons.server;
            const radius = (deviceConfig.size / 2) + 30; // Device size + label space
            
            minX = Math.min(minX, device.x - radius);
            minY = Math.min(minY, device.y - radius);
            maxX = Math.max(maxX, device.x + radius);
            maxY = Math.max(maxY, device.y + radius);
            deviceCount++;
        }
    });
    
    console.log(`Found ${deviceCount} devices. Bounds: (${minX}, ${minY}) to (${maxX}, ${maxY})`);
    
    // If no devices found, use default size
    if (deviceCount === 0) {
        const container = document.getElementById('network-diagram-container');
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight || 700;
        
        svg.setAttribute('width', containerWidth);
        svg.setAttribute('height', containerHeight);
        svg.setAttribute('viewBox', `0 0 ${containerWidth} ${containerHeight}`);
        return;
    }
    
    // Add padding around the content
    const padding = 100;
    minX = Math.max(0, minX - padding); // Don't go negative
    minY = Math.max(0, minY - padding);
    maxX += padding;
    maxY += padding;
    
    // Calculate content dimensions
    const contentWidth = maxX - minX;
    const contentHeight = maxY - minY;
    
    // Ensure the SVG canvas is large enough to contain all devices
    const container = document.getElementById('network-diagram-container');
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight || 700;
    
    // Set SVG to be large enough for the full content
    const newWidth = Math.max(containerWidth, contentWidth);
    const newHeight = Math.max(containerHeight, contentHeight);
    
    console.log(`Setting SVG size: ${newWidth}x${newHeight}`);
    
    // Update SVG dimensions but keep current viewBox if panning
    svg.setAttribute('width', newWidth);
    svg.setAttribute('height', newHeight);
    
    // Only update viewBox if not in pan mode to preserve user's view
    if (!isPanMode || !svg.getAttribute('viewBox')) {
        svg.setAttribute('viewBox', `${minX} ${minY} ${contentWidth} ${contentHeight}`);
    }
    
    // Force container to recognize the new size
    svg.style.display = 'block';
    svg.style.minWidth = newWidth + 'px';
    svg.style.minHeight = newHeight + 'px';
}

// ============================================
// LAYOUT MANAGEMENT (Server-side)
// ============================================

// Save current layout to server
function saveLayout() {
    if (!networkStructure || !hasCustomChanges) {
        showMessage('No custom changes to save.', 'warning');
        return;
    }
    
    // Create layout data with device positions
    const layoutData = {
        timestamp: new Date().toISOString(),
        devices: {}
    };
    
    // Store device positions
    Object.keys(networkStructure.devices).forEach(deviceId => {
        const device = networkStructure.devices[deviceId];
        layoutData.devices[deviceId] = {
            x: device.x,
            y: device.y,
            segment: device.segment,
            deviceType: device.deviceType
        };
    });
    
    // Disable save button during save
    const saveBtn = document.getElementById('save-layout-btn');
    saveBtn.disabled = true;
    saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
    
    // Save to server
    fetch('/api/diagram_layout', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            layout_name: 'default',
            layout_data: layoutData,
            created_by: 'user'
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Reset custom changes flag
            hasCustomChanges = false;
            showMessage('Layout saved successfully!', 'success');
            console.log('Layout saved to server:', layoutData);
        } else {
            showMessage(`Failed to save layout: ${data.error || 'Unknown error'}`, 'error');
        }
    })
    .catch(error => {
        console.error('Error saving layout:', error);
        showMessage('Failed to save layout to server', 'error');
    })
    .finally(() => {
        // Reset save button
        saveBtn.innerHTML = '<i class="fas fa-save"></i> Save Layout';
        if (!hasCustomChanges) {
            saveBtn.disabled = true;
        }
    });
}

// Load saved layout from server
function loadSavedLayout() {
    return fetch('/api/diagram_layout?name=default')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.layout) {
                customLayout = data.layout.layout_data;
                console.log('Loaded saved layout from server:', customLayout);
                return true;
            } else {
                console.log('No saved layout found on server');
                return false;
            }
        })
        .catch(error => {
            console.error('Error loading saved layout from server:', error);
            return false;
        });
}

// Apply saved layout to devices
function applySavedLayout(structure) {
    if (!customLayout || !customLayout.devices) return false;
    
    let appliedCount = 0;
    
    Object.keys(structure.devices).forEach(deviceId => {
        const savedPosition = customLayout.devices[deviceId];
        if (savedPosition) {
            structure.devices[deviceId].x = savedPosition.x;
            structure.devices[deviceId].y = savedPosition.y;
            appliedCount++;
        }
    });
    
    if (appliedCount > 0) {
        console.log(`Applied saved positions to ${appliedCount} devices`);
        showMessage(`Applied saved layout to ${appliedCount} devices.`, 'info');
        return true;
    }
    
    return false;
}

// Reset to automatic layout
function resetLayout() {
    // Clear custom layout
    customLayout = null;
    hasCustomChanges = false;
    localStorage.removeItem('networkDiagramLayout');
    
    // If we have an existing network structure, reposition devices within current bounds
    if (networkStructure) {
        repositionDevicesWithinBounds();
    } else {
        // Regenerate diagram with automatic layout
        generateNetworkDiagram();
    }
    
    // Update UI
    document.getElementById('save-layout-btn').disabled = true;
    
    showMessage('Layout reset - devices repositioned within panel bounds.', 'info');
}

// Reposition all devices to fit within current panel bounds
function repositionDevicesWithinBounds() {
    if (!networkStructure) return;
    
    const container = document.getElementById('network-diagram-container');
    const width = container.clientWidth;
    const height = container.clientHeight || 700;
    
    console.log('Repositioning devices within bounds:', width, 'x', height);
    
    // Re-layout devices using the same logic as initial layout but with current bounds
    layoutDevices(networkStructure, width, height);
    
    // Update visual positions of all devices
    Object.keys(networkStructure.devices).forEach(deviceId => {
        const device = networkStructure.devices[deviceId];
        if (device.x !== undefined && device.y !== undefined) {
            updateDeviceVisualPosition(deviceId, device.x, device.y);
        }
    });
    
    // Redraw connections
    redrawConnections();
    
    // Reset SVG to fit the container
    const svg = document.querySelector('#network-diagram-container svg');
    if (svg) {
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        svg.style.minWidth = width + 'px';
        svg.style.minHeight = height + 'px';
    }
    
    console.log('Devices repositioned within panel bounds');
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

// Show temporary message
function showMessage(message, type = 'info') {
    // Create message element
    const messageDiv = document.createElement('div');
    messageDiv.className = `alert alert-${type === 'info' ? 'primary' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : 'danger'} alert-dismissible fade show position-fixed`;
    messageDiv.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 400px;';
    messageDiv.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    // Add to page
    document.body.appendChild(messageDiv);
    
    // Auto-remove after 4 seconds
    setTimeout(() => {
        if (messageDiv.parentNode) {
            messageDiv.remove();
        }
    }, 4000);
}

// ============================================
// ENHANCED DIAGRAM GENERATION
// ============================================

// Enhanced diagram generation with async layout loading
function generateNetworkDiagram() {
    if (!diagramData || !diagramData.nodes) return;
    
    const container = document.getElementById('network-diagram-container');
    const width = container.clientWidth;
    const height = container.clientHeight || 700;
    
    // Clear existing diagram
    container.innerHTML = '';
    
    // Create SVG
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    svg.style.background = '#f8f9fa';
    
    // Analyze network structure
    networkStructure = analyzeNetworkStructure(diagramData, width, height);
    
    // Load saved layout asynchronously, then render
    if (!customLayout) {
        loadSavedLayout().then((layoutLoaded) => {
            if (layoutLoaded && customLayout) {
                applySavedLayout(networkStructure);
            }
            renderDiagram(svg, networkStructure);
        });
    } else {
        // Apply existing custom layout
        applySavedLayout(networkStructure);
        renderDiagram(svg, networkStructure);
    }
}

// Render the actual diagram elements
function renderDiagram(svg, structure) {
    // Draw network segments
    drawNetworkSegments(svg, structure, svg.clientWidth || 800, svg.clientHeight || 700);
    
    // Draw connections
    drawConnections(svg, structure);
    
    // Draw devices
    drawDevices(svg, structure);
    
    // Enable dragging if drag mode is active
    if (isDragMode) {
        setTimeout(() => enableDragging(), 100);
    }
    
    // Add to container
    const container = document.getElementById('network-diagram-container');
    container.appendChild(svg);
    
    console.log('Network diagram rendered successfully');
}

// ============================================
// DEVICE EDIT FUNCTIONALITY
// ============================================

// Open device edit modal
function openDeviceEditModal(deviceId) {
    if (!networkStructure || !networkStructure.devices[deviceId]) {
        showMessage('Device not found!', 'error');
        return;
    }
    
    const device = networkStructure.devices[deviceId];
    
    // Populate modal fields
    document.getElementById('editDeviceId').value = deviceId;
    document.getElementById('editDeviceName').value = device.label || device.ip || '';
    document.getElementById('editDeviceType').value = device.deviceType || 'server';
    document.getElementById('editDeviceNotes').value = device.notes || '';
    
    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('deviceEditModal'));
    modal.show();
}

// Save device changes
function saveDeviceChanges() {
    const deviceId = document.getElementById('editDeviceId').value;
    const deviceName = document.getElementById('editDeviceName').value.trim();
    const deviceType = document.getElementById('editDeviceType').value;
    const deviceNotes = document.getElementById('editDeviceNotes').value.trim();
    
    if (!deviceId || !networkStructure || !networkStructure.devices[deviceId]) {
        showMessage('Device not found!', 'error');
        return;
    }
    
    if (!deviceName) {
        showMessage('Device name is required!', 'warning');
        return;
    }
    
    const device = networkStructure.devices[deviceId];
    const originalLabel = device.label;
    const originalType = device.deviceType;
    
    // Update device in memory
    device.label = deviceName;
    device.deviceType = deviceType;
    device.notes = deviceNotes;
    
    // Create update data
    const updateData = {
        device_id: deviceId,
        label: deviceName,
        device_type: deviceType,
        notes: deviceNotes,
        ip: device.ip
    };
    
    // Save to server
    fetch('/api/update_device', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(updateData)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Update the diagram if the type changed
            if (originalType !== deviceType) {
                updateDeviceIcon(deviceId, deviceType);
            }
            
            // Update the label if it changed
            if (originalLabel !== deviceName) {
                updateDeviceLabel(deviceId, deviceName);
            }
            
            // Refresh the device details panel if this device is selected
            if (selectedDevice && selectedDevice.id === deviceId) {
                showDeviceDetails(device);
            }
            
            // Hide modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('deviceEditModal'));
            modal.hide();
            
            showMessage('Device updated successfully!', 'success');
            console.log('Device updated:', updateData);
        } else {
            showMessage(`Failed to update device: ${data.error || 'Unknown error'}`, 'error');
        }
    })
    .catch(error => {
        console.error('Error updating device:', error);
        showMessage('Failed to save device changes', 'error');
    });
}

// Update device icon in the diagram
function updateDeviceIcon(deviceId, newDeviceType) {
    const deviceElement = document.querySelector(`[data-device-id="${deviceId}"]`);
    if (!deviceElement) return;
    
    const device = networkStructure.devices[deviceId];
    const deviceConfig = deviceIcons[newDeviceType] || deviceIcons.server;
    
    // Update circle stroke color
    const circle = deviceElement.querySelector('circle');
    if (circle) {
        circle.setAttribute('stroke', deviceConfig.color);
    }
    
    // Update icon symbol and color
    const iconText = deviceElement.querySelector('text');
    if (iconText) {
        iconText.textContent = getDeviceIconSymbol(newDeviceType);
        iconText.setAttribute('fill', deviceConfig.color);
    }
    
    console.log(`Updated device ${deviceId} icon to ${newDeviceType}`);
}

// Update device label in the diagram
function updateDeviceLabel(deviceId, newLabel) {
    const deviceElement = document.querySelector(`[data-device-id="${deviceId}"]`);
    if (!deviceElement) return;
    
    // Update the label text (second text element)
    const labels = deviceElement.querySelectorAll('text');
    if (labels.length > 1) {
        labels[1].textContent = newLabel;
    }
    
    console.log(`Updated device ${deviceId} label to "${newLabel}"`);
}

// ============================================
// CONNECTIVITY ANALYSIS FUNCTIONALITY
// ============================================

// Toggle connectivity analysis mode
function toggleConnectivityMode() {
    connectivityMode = !connectivityMode;
    const connectivityBtn = document.getElementById('connectivity-btn');
    const connectivityModeText = document.getElementById('connectivity-mode-text');
    
    if (connectivityMode) {
        // Enable connectivity mode
        connectivityBtn.classList.remove('btn-outline-primary');
        connectivityBtn.classList.add('btn-danger');
        connectivityModeText.textContent = 'Exit Analysis';
        
        // Disable other modes
        if (isDragMode) toggleDragMode();
        if (isPanMode) togglePanMode();
        
        // Clear any existing selections
        clearDeviceSelections();
        selectedDevices = [];
        
        // Change click behavior
        enableConnectivitySelection();
        
        showMessage('üîç Connectivity Analysis Mode: Click two devices to analyze their connections', 'info');
    } else {
        // Disable connectivity mode
        connectivityBtn.classList.remove('btn-danger');
        connectivityBtn.classList.add('btn-outline-primary');
        connectivityModeText.textContent = 'Connectivity';
        
        // Clear selections and analysis
        clearConnectivityAnalysis();
        disableConnectivitySelection();
        
        showMessage('Connectivity analysis mode disabled', 'info');
    }
}

// Enable connectivity selection mode
function enableConnectivitySelection() {
    const deviceIcons = document.querySelectorAll('.device-icon');
    deviceIcons.forEach(icon => {
        icon.style.cursor = 'crosshair';
    });
}

// Disable connectivity selection mode
function disableConnectivitySelection() {
    const deviceIcons = document.querySelectorAll('.device-icon');
    deviceIcons.forEach(icon => {
        icon.style.cursor = 'pointer';
    });
}

// Clear device selections
function clearDeviceSelections() {
    document.querySelectorAll('.device-icon').forEach(el => {
        el.classList.remove('device-selected', 'device-connectivity-selected');
    });
}

// Clear connectivity analysis
function clearConnectivityAnalysis() {
    clearDeviceSelections();
    selectedDevices = [];
    
    // Remove analysis lines
    const svg = document.querySelector('#network-diagram-container svg');
    if (svg) {
        const analysisLines = svg.querySelectorAll('.connectivity-analysis-line');
        analysisLines.forEach(line => line.remove());
    }
    
    // Reset device details panel if showing connectivity analysis
    const deviceInfoCards = document.getElementById('device-info-cards');
    if (deviceInfoCards && deviceInfoCards.innerHTML.includes('Connectivity Analysis')) {
        deviceInfoCards.innerHTML = `
            <div class="text-center text-muted">
                <i class="fas fa-mouse-pointer fa-3x mb-3 text-secondary"></i>
                <p>Click on a device in the diagram to view details</p>
                <small class="text-muted">Device information will appear here when selected</small>
            </div>
        `;
    }
}

// Handle device selection in connectivity mode
function selectDeviceForConnectivity(device) {
    if (!connectivityMode) {
        // Normal device selection
        selectDevice(device);
        return;
    }
    
    // Check if device is already selected
    const isAlreadySelected = selectedDevices.some(d => d.id === device.id);
    if (isAlreadySelected) {
        showMessage('Device already selected for analysis', 'warning');
        return;
    }
    
    // Add device to selection
    selectedDevices.push(device);
    
    // Update visual selection
    const deviceElement = document.querySelector(`[data-device-id="${device.id}"]`);
    if (deviceElement) {
        deviceElement.classList.add('device-connectivity-selected');
    }
    
    if (selectedDevices.length === 1) {
        showMessage(`First device selected: ${device.label || device.ip}. Select a second device to analyze connectivity.`, 'info');
    } else if (selectedDevices.length === 2) {
        // Analyze connectivity between the two devices
        analyzeDeviceConnectivity(selectedDevices[0], selectedDevices[1]);
    } else if (selectedDevices.length > 2) {
        // Too many devices selected, reset
        clearConnectivityAnalysis();
        selectedDevices = [device];
        if (deviceElement) {
            deviceElement.classList.add('device-connectivity-selected');
        }
        showMessage('Too many devices selected. Starting over with this device.', 'warning');
    }
}

// Analyze connectivity between two devices
function analyzeDeviceConnectivity(device1, device2) {
    console.log(`Analyzing connectivity between ${device1.label || device1.ip} and ${device2.label || device2.ip}`);
    
    showMessage(`üîç Analyzing connectivity between ${device1.label || device1.ip} and ${device2.label || device2.ip}...`, 'info');
    
    // Draw analysis line between devices
    drawConnectivityAnalysisLine(device1, device2);
    
    // Get comprehensive connectivity data
    const connectivityData = getComprehensiveConnectivity(device1, device2);
    
    // Display analysis results
    displayConnectivityAnalysis(device1, device2, connectivityData);
}

// Draw animated line between two devices for analysis
function drawConnectivityAnalysisLine(device1, device2) {
    const svg = document.querySelector('#network-diagram-container svg');
    if (!svg) return;
    
    // Remove any existing analysis lines
    const existingLines = svg.querySelectorAll('.connectivity-analysis-line');
    existingLines.forEach(line => line.remove());
    
    // Draw new analysis line
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', device1.x);
    line.setAttribute('y1', device1.y);
    line.setAttribute('x2', device2.x);
    line.setAttribute('y2', device2.y);
    line.setAttribute('class', 'connectivity-analysis-line');
    
    svg.appendChild(line);
}

// Get comprehensive connectivity information between two devices
function getComprehensiveConnectivity(device1, device2) {
    const connectivity = {
        directConnections: [],
        intermediateDevices: [],
        pathAnalysis: [],
        networkSegments: {
            device1Segment: device1.segment,
            device2Segment: device2.segment,
            crossSegment: device1.segment !== device2.segment
        },
        protocolBreakdown: {},
        portAnalysis: {},
        routingPath: [],
        securityImplications: [],
        performanceMetrics: {}
    };
    
    if (!networkStructure || !networkStructure.connections) {
        return connectivity;
    }
    
    // Find direct connections between the two devices
    networkStructure.connections.forEach(connection => {
        const isDirectConnection = 
            (connection.from === device1.id && connection.to === device2.id) ||
            (connection.from === device2.id && connection.to === device1.id);
        
        if (isDirectConnection) {
            connectivity.directConnections.push({
                ...connection,
                direction: connection.from === device1.id ? 'device1_to_device2' : 'device2_to_device1'
            });
            
            // Track protocols
            const protocol = connection.protocol || 'unknown';
            connectivity.protocolBreakdown[protocol] = (connectivity.protocolBreakdown[protocol] || 0) + 1;
            
            // Track ports
            if (connection.port) {
                const port = connection.port;
                if (!connectivity.portAnalysis[port]) {
                    connectivity.portAnalysis[port] = {
                        protocol: protocol,
                        service: getServiceForPort(port),
                        direction: connection.from === device1.id ? 'outgoing' : 'incoming'
                    };
                }
            }
        }
    });
    
    // Find intermediate devices and paths
    const pathsToDevice2 = findAllPaths(device1.id, device2.id, networkStructure, 3); // Max 3 hops
    connectivity.pathAnalysis = pathsToDevice2;
    
    // Extract intermediate devices
    pathsToDevice2.forEach(path => {
        if (path.length > 2) {
            for (let i = 1; i < path.length - 1; i++) {
                const intermediateId = path[i];
                const intermediateDevice = networkStructure.devices[intermediateId];
                if (intermediateDevice && !connectivity.intermediateDevices.some(d => d.id === intermediateId)) {
                    connectivity.intermediateDevices.push(intermediateDevice);
                }
            }
        }
    });
    
    // Analyze security implications
    analyzeSecurityImplications(device1, device2, connectivity);
    
    // Analyze routing and network topology
    analyzeRoutingPath(device1, device2, connectivity);
    
    return connectivity;
}

// Find all paths between two devices (BFS with limited depth)
function findAllPaths(startId, endId, structure, maxDepth = 3) {
    const paths = [];
    const visited = new Set();
    
    function dfs(currentId, targetId, currentPath, depth) {
        if (depth > maxDepth) return;
        if (currentId === targetId) {
            paths.push([...currentPath]);
            return;
        }
        
        visited.add(currentId);
        
        // Find all connections from current device
        structure.connections.forEach(connection => {
            let nextId = null;
            if (connection.from === currentId) {
                nextId = connection.to;
            } else if (connection.to === currentId) {
                nextId = connection.from;
            }
            
            if (nextId && !visited.has(nextId)) {
                currentPath.push(nextId);
                dfs(nextId, targetId, currentPath, depth + 1);
                currentPath.pop();
            }
        });
        
        visited.delete(currentId);
    }
    
    dfs(startId, endId, [startId], 0);
    return paths;
}

// Get service name for port number
function getServiceForPort(port) {
    const commonPorts = {
        20: 'FTP Data',
        21: 'FTP Control',
        22: 'SSH',
        23: 'Telnet',
        25: 'SMTP',
        53: 'DNS',
        67: 'DHCP Server',
        68: 'DHCP Client',
        80: 'HTTP',
        110: 'POP3',
        143: 'IMAP',
        443: 'HTTPS',
        993: 'IMAPS',
        995: 'POP3S',
        3389: 'RDP',
        5432: 'PostgreSQL',
        3306: 'MySQL',
        1521: 'Oracle',
        6379: 'Redis',
        27017: 'MongoDB'
    };
    
    return commonPorts[port] || `Port ${port}`;
}

// Analyze security implications
function analyzeSecurityImplications(device1, device2, connectivity) {
    // Check for cross-segment communication
    if (connectivity.networkSegments.crossSegment) {
        connectivity.securityImplications.push({
            type: 'Cross-Segment Communication',
            severity: 'medium',
            description: `Communication between different network segments (${device1.segment} ‚Üî ${device2.segment})`
        });
    }
    
    // Check for sensitive ports
    Object.keys(connectivity.portAnalysis).forEach(port => {
        const portNum = parseInt(port);
        if ([22, 23, 3389, 5432, 3306, 1521].includes(portNum)) {
            connectivity.securityImplications.push({
                type: 'Sensitive Service',
                severity: 'high',
                description: `${connectivity.portAnalysis[port].service} (${port}) - requires secure access controls`
            });
        }
    });
    
    // Check for unencrypted protocols
    Object.keys(connectivity.protocolBreakdown).forEach(protocol => {
        if (['http', 'ftp', 'telnet', 'smtp'].includes(protocol.toLowerCase())) {
            connectivity.securityImplications.push({
                type: 'Unencrypted Protocol',
                severity: 'medium',
                description: `${protocol.toUpperCase()} traffic is unencrypted`
            });
        }
    });
    
    // Check device types for security concerns
    if (device1.deviceType === 'firewall' || device2.deviceType === 'firewall') {
        connectivity.securityImplications.push({
            type: 'Firewall Path',
            severity: 'info',
            description: 'Communication path includes firewall - traffic likely filtered'
        });
    }
}

// Analyze routing path
function analyzeRoutingPath(device1, device2, connectivity) {
    // Determine likely routing path based on device types and network segments
    const path = [];
    
    if (connectivity.networkSegments.crossSegment) {
        // Cross-segment communication - look for routers or gateways
        const routingDevices = connectivity.intermediateDevices.filter(device => 
            ['router', 'gateway', 'firewall'].includes(device.deviceType)
        );
        
        if (routingDevices.length > 0) {
            connectivity.routingPath = [
                device1,
                ...routingDevices,
                device2
            ];
        } else {
            connectivity.routingPath = [device1, device2];
        }
    } else {
        // Same segment - look for switches
        const switchingDevices = connectivity.intermediateDevices.filter(device => 
            device.deviceType === 'switch'
        );
        
        if (switchingDevices.length > 0) {
            connectivity.routingPath = [
                device1,
                switchingDevices[0], // Usually just one switch in a segment
                device2
            ];
        } else {
            connectivity.routingPath = [device1, device2];
        }
    }
}

// Display comprehensive connectivity analysis
function displayConnectivityAnalysis(device1, device2, connectivity) {
    const deviceInfoCards = document.getElementById('device-info-cards');
    
    const device1Config = deviceIcons[device1.deviceType] || deviceIcons.server;
    const device2Config = deviceIcons[device2.deviceType] || deviceIcons.server;
    
    deviceInfoCards.innerHTML = `
        <div class="card border-danger mb-3">
            <div class="card-header bg-danger text-white">
                <h6 class="mb-0">
                    <i class="fas fa-sitemap me-2"></i>Connectivity Analysis
                    <button class="btn btn-light btn-sm float-end" onclick="clearConnectivityAnalysis()" title="Clear Analysis">
                        <i class="fas fa-times"></i>
                    </button>
                </h6>
            </div>
            <div class="card-body">
                <div class="row mb-3">
                    <div class="col-6">
                        <div class="text-center p-2 border rounded">
                            <i class="${device1Config.icon} fa-2x mb-2" style="color: ${device1Config.color}"></i>
                            <div class="fw-bold small">${device1.label || device1.ip}</div>
                            <div class="text-muted small">${device1.deviceType}</div>
                        </div>
                    </div>
                    <div class="col-6">
                        <div class="text-center p-2 border rounded">
                            <i class="${device2Config.icon} fa-2x mb-2" style="color: ${device2Config.color}"></i>
                            <div class="fw-bold small">${device2.label || device2.ip}</div>
                            <div class="text-muted small">${device2.deviceType}</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        ${generateDirectConnectionsCard(connectivity)}
        ${generatePathAnalysisCard(connectivity)}
        ${generateProtocolAnalysisCard(connectivity)}
        ${generateSecurityAnalysisCard(connectivity)}
        ${generateNetworkTopologyCard(device1, device2, connectivity)}
    `;
}

// Generate direct connections card
function generateDirectConnectionsCard(connectivity) {
    const directCount = connectivity.directConnections.length;
    
    if (directCount === 0) {
        return `
            <div class="card border-warning mb-3">
                <div class="card-header bg-warning text-dark">
                    <h6 class="mb-0"><i class="fas fa-link me-2"></i>Direct Connections</h6>
                </div>
                <div class="card-body">
                    <div class="text-center text-muted">
                        <i class="fas fa-unlink fa-2x mb-2"></i>
                        <p class="mb-0">No direct connections detected</p>
                        <small>Communication may occur through intermediate devices</small>
                    </div>
                </div>
            </div>
        `;
    }
    
    let connectionsHtml = '';
    connectivity.directConnections.forEach(connection => {
        const direction = connection.direction === 'device1_to_device2' ? 
            '<i class="fas fa-arrow-right text-success"></i>' : 
            '<i class="fas fa-arrow-left text-info"></i>';
        
        connectionsHtml += `
            <div class="border rounded p-2 mb-2 bg-light">
                <div class="d-flex justify-content-between align-items-center">
                    <span><strong>${connection.protocol?.toUpperCase() || 'Unknown'}</strong></span>
                    ${direction}
                </div>
                ${connection.port ? `<small class="text-muted">Port: ${connection.port} (${getServiceForPort(connection.port)})</small>` : ''}
            </div>
        `;
    });
    
    return `
        <div class="card border-success mb-3">
            <div class="card-header bg-success text-white">
                <h6 class="mb-0"><i class="fas fa-link me-2"></i>Direct Connections (${directCount})</h6>
            </div>
            <div class="card-body">
                ${connectionsHtml}
            </div>
        </div>
    `;
}

// Generate path analysis card
function generatePathAnalysisCard(connectivity) {
    const pathCount = connectivity.pathAnalysis.length;
    const intermediateCount = connectivity.intermediateDevices.length;
    
    if (pathCount === 0) {
        return `
            <div class="card border-secondary mb-3">
                <div class="card-header bg-secondary text-white">
                    <h6 class="mb-0"><i class="fas fa-route me-2"></i>Network Paths</h6>
                </div>
                <div class="card-body">
                    <div class="text-center text-muted">
                        <i class="fas fa-ban fa-2x mb-2"></i>
                        <p class="mb-0">No network paths found</p>
                        <small>Devices may not be connected or path exceeds maximum depth</small>
                    </div>
                </div>
            </div>
        `;
    }
    
    let pathsHtml = '';
    connectivity.pathAnalysis.forEach((path, index) => {
        let pathDescription = '';
        path.forEach((deviceId, i) => {
            const device = networkStructure.devices[deviceId];
            if (device) {
                pathDescription += device.label || device.ip;
                if (i < path.length - 1) pathDescription += ' ‚Üí ';
            }
        });
        
        pathsHtml += `
            <div class="small mb-2 p-2 border rounded bg-light">
                <strong>Path ${index + 1}:</strong> ${pathDescription}
                <br><small class="text-muted">${path.length - 1} hop${path.length - 1 !== 1 ? 's' : ''}</small>
            </div>
        `;
    });
    
    return `
        <div class="card border-info mb-3">
            <div class="card-header bg-info text-white">
                <h6 class="mb-0">
                    <i class="fas fa-route me-2"></i>Network Paths (${pathCount})
                    ${intermediateCount > 0 ? `‚Ä¢ ${intermediateCount} intermediate device${intermediateCount !== 1 ? 's' : ''}` : ''}
                </h6>
            </div>
            <div class="card-body">
                ${pathsHtml}
            </div>
        </div>
    `;
}

// Generate protocol analysis card
function generateProtocolAnalysisCard(connectivity) {
    const protocolCount = Object.keys(connectivity.protocolBreakdown).length;
    const portCount = Object.keys(connectivity.portAnalysis).length;
    
    if (protocolCount === 0 && portCount === 0) {
        return '';
    }
    
    let protocolsHtml = '';
    Object.entries(connectivity.protocolBreakdown).forEach(([protocol, count]) => {
        protocolsHtml += `
            <span class="badge bg-primary me-2 mb-2">${protocol.toUpperCase()} (${count})</span>
        `;
    });
    
    let portsHtml = '';
    Object.entries(connectivity.portAnalysis).forEach(([port, info]) => {
        const badgeColor = ['22', '443', '993', '995'].includes(port) ? 'success' : 
                          ['80', '21', '23'].includes(port) ? 'warning' : 'secondary';
        portsHtml += `
            <div class="d-flex justify-content-between align-items-center mb-2 p-2 border rounded bg-light">
                <div>
                    <span class="badge bg-${badgeColor}">${port}</span>
                    <strong class="ms-2">${info.service}</strong>
                </div>
                <small class="text-muted">${info.protocol.toUpperCase()} ‚Ä¢ ${info.direction}</small>
            </div>
        `;
    });
    
    return `
        <div class="card border-primary mb-3">
            <div class="card-header bg-primary text-white">
                <h6 class="mb-0"><i class="fas fa-exchange-alt me-2"></i>Protocol & Port Analysis</h6>
            </div>
            <div class="card-body">
                ${protocolCount > 0 ? `
                    <div class="mb-3">
                        <strong>Protocols:</strong><br>
                        ${protocolsHtml}
                    </div>
                ` : ''}
                ${portCount > 0 ? `
                    <div>
                        <strong>Ports & Services:</strong>
                        <div class="mt-2">${portsHtml}</div>
                    </div>
                ` : ''}
            </div>
        </div>
    `;
}

// Generate security analysis card
function generateSecurityAnalysisCard(connectivity) {
    const securityCount = connectivity.securityImplications.length;
    
    if (securityCount === 0) {
        return `
            <div class="card border-success mb-3">
                <div class="card-header bg-success text-white">
                    <h6 class="mb-0"><i class="fas fa-shield-alt me-2"></i>Security Analysis</h6>
                </div>
                <div class="card-body">
                    <div class="text-center text-success">
                        <i class="fas fa-check-circle fa-2x mb-2"></i>
                        <p class="mb-0">No security concerns detected</p>
                        <small>Communication appears to follow standard security practices</small>
                    </div>
                </div>
            </div>
        `;
    }
    
    let securityHtml = '';
    connectivity.securityImplications.forEach(implication => {
        const badgeColor = implication.severity === 'high' ? 'danger' : 
                          implication.severity === 'medium' ? 'warning' : 'info';
        const icon = implication.severity === 'high' ? 'exclamation-triangle' : 
                    implication.severity === 'medium' ? 'exclamation-circle' : 'info-circle';
        
        securityHtml += `
            <div class="d-flex align-items-start mb-2 p-2 border border-${badgeColor} rounded bg-light">
                <i class="fas fa-${icon} text-${badgeColor} me-2 mt-1"></i>
                <div class="flex-grow-1">
                    <div class="fw-bold">${implication.type}</div>
                    <div class="small text-muted">${implication.description}</div>
                </div>
                <span class="badge bg-${badgeColor} small">${implication.severity.toUpperCase()}</span>
            </div>
        `;
    });
    
    return `
        <div class="card border-warning mb-3">
            <div class="card-header bg-warning text-dark">
                <h6 class="mb-0"><i class="fas fa-shield-alt me-2"></i>Security Analysis (${securityCount} item${securityCount !== 1 ? 's' : ''})</h6>
            </div>
            <div class="card-body">
                ${securityHtml}
            </div>
        </div>
    `;
}

// Generate network topology card
function generateNetworkTopologyCard(device1, device2, connectivity) {
    const isCrossSegment = connectivity.networkSegments.crossSegment;
    const routingPath = connectivity.routingPath;
    
    let topologyHtml = `
        <div class="mb-3">
            <strong>Network Segments:</strong><br>
            <div class="row">
                <div class="col-6">
                    <div class="p-2 border rounded text-center ${isCrossSegment ? 'border-warning' : 'border-success'}">
                        <div class="small text-muted">Device 1</div>
                        <strong>${device1.segment}</strong>
                    </div>
                </div>
                <div class="col-6">
                    <div class="p-2 border rounded text-center ${isCrossSegment ? 'border-warning' : 'border-success'}">
                        <div class="small text-muted">Device 2</div>
                        <strong>${device2.segment}</strong>
                    </div>
                </div>
            </div>
            ${isCrossSegment ? '<small class="text-warning"><i class="fas fa-exclamation-triangle"></i> Cross-segment communication</small>' : '<small class="text-success"><i class="fas fa-check"></i> Same network segment</small>'}
        </div>
    `;
    
    if (routingPath.length > 0) {
        let pathHtml = '';
        routingPath.forEach((device, index) => {
            const deviceConfig = deviceIcons[device.deviceType] || deviceIcons.server;
            pathHtml += `
                <div class="text-center">
                    <i class="${deviceConfig.icon} fa-lg" style="color: ${deviceConfig.color}"></i>
                    <div class="small fw-bold">${device.label || device.ip}</div>
                    <div class="small text-muted">${device.deviceType}</div>
                </div>
            `;
            
            if (index < routingPath.length - 1) {
                pathHtml += '<div class="text-center"><i class="fas fa-arrow-down text-muted"></i></div>';
            }
        });
        
        topologyHtml += `
            <div class="mt-3">
                <strong>Expected Routing Path:</strong>
                <div class="mt-2 p-3 border rounded bg-light">
                    ${pathHtml}
                </div>
            </div>
        `;
    }
    
    return `
        <div class="card border-secondary">
            <div class="card-header bg-secondary text-white">
                <h6 class="mb-0"><i class="fas fa-project-diagram me-2"></i>Network Topology</h6>
            </div>
            <div class="card-body">
                ${topologyHtml}
            </div>
        </div>
    `;
}

// Override the original selectDevice function to handle connectivity mode
const originalSelectDevice = selectDevice;
selectDevice = function(device) {
    if (connectivityMode) {
        selectDeviceForConnectivity(device);
    } else {
        originalSelectDevice(device);
    }
};
</script>
{% endblock %}
