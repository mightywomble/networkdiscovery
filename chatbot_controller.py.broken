#!/usr/bin/env python3
"""
Chatbot Controller for NetworkMap
Orchestrates the conversation flow, command generation, validation, and execution
"""

import json
import uuid
import threading
import time
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import logging

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ChatbotController:
    """Main controller for the NetworkMap AI Chatbot"""
    
    def __init__(self, database, host_manager):
        """
        Initialize the Chatbot Controller
        
        Args:
            database: Database instance
            host_manager: HostManager instance for remote execution
        """
        self.db = database
        self.host_manager = host_manager
        
        # Initialize components
        from ai_command_generator import AICommandGenerator
        from command_validator import CommandValidator
        
        self.command_generator = AICommandGenerator(database)
        self.command_validator = CommandValidator()
        
        # Active conversations and executions
        self.active_conversations = {}
        self.active_executions = {}
        
        # Conversation states
        self.CONVERSATION_STATES = {
            'initial': 'initial',
            'awaiting_request': 'awaiting_request',
            'script_generated': 'script_generated',
            'script_validated': 'script_validated',
            'awaiting_approval': 'awaiting_approval',
            'executing': 'executing',
            'completed': 'completed',
            'error': 'error'
        }
    
    def start_conversation(self, user_id: str = None) -> Dict[str, Any]:
        """
        Start a new chatbot conversation
        
        Args:
            user_id: Optional user identifier
            
        Returns:
            dict: Conversation initialization response
        """
        try:
            conversation_id = str(uuid.uuid4())
            
            conversation = {
                'id': conversation_id,
                'user_id': user_id,
                'created_at': datetime.now().isoformat(),
                'updated_at': datetime.now().isoformat(),
                'state': self.CONVERSATION_STATES['initial'],
                'messages': [],
                'current_script': None,
                'validation_result': None,
                'selected_hosts': [],
                'execution_results': None
            }
            
            self.active_conversations[conversation_id] = conversation
            
            # Save to database
            self._save_conversation(conversation)
            
            # Add welcome message
            welcome_message = {
                'id': str(uuid.uuid4()),
                'type': 'bot',
                'content': self._get_welcome_message(),
                'timestamp': datetime.now().isoformat(),
                'metadata': {
                    'conversation_state': 'initial',
                    'available_actions': ['request_command']
                }
            }
            
            conversation['messages'].append(welcome_message)
            conversation['state'] = self.CONVERSATION_STATES['awaiting_request']
            conversation['updated_at'] = datetime.now().isoformat()
            
            # Save conversation with welcome message
            self._save_conversation(conversation)
            
            logger.info(f"Started new conversation: {conversation_id}")
            
            return {
                'success': True,
                'conversation_id': conversation_id,
                'message': welcome_message,
                'conversation_state': conversation['state']
            }
            
        except Exception as e:
            logger.error(f"Error starting conversation: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def process_user_message(self, conversation_id: str, user_message: str, selected_hosts: List[Dict] = None) -> Dict[str, Any]:
        """
        Process a user message and generate appropriate response
        
        Args:
            conversation_id: ID of the conversation
            user_message: User's message/request
            selected_hosts: List of selected host dictionaries
            
        Returns:
            dict: Bot response with actions
        """
        try:
            conversation = self.active_conversations.get(conversation_id)
            if not conversation:
                # Try to load from database
                conversation = self.db.get_chatbot_conversation(conversation_id)
                if conversation:
                    self.active_conversations[conversation_id] = conversation
                else:
                    return {
                        'success': False,
                        'error': 'Conversation not found'
                    }
            
            # Add user message to conversation
            user_msg = {
                'id': str(uuid.uuid4()),
                'type': 'user',
                'content': user_message,
                'timestamp': datetime.now().isoformat(),
                'metadata': {
                    'selected_hosts': selected_hosts or []
                }
            }
            
            conversation['messages'].append(user_msg)
            if selected_hosts:
                conversation['selected_hosts'] = selected_hosts
            
            # Process based on current conversation state
            response = self._process_message_by_state(conversation, user_message)
            
            # Add bot response to conversation
            if response.get('success'):
                conversation['messages'].append(response['message'])
                conversation['updated_at'] = datetime.now().isoformat()
                
                # Save updated conversation
                self._save_conversation(conversation)
            
            logger.info(f"Processed message in conversation {conversation_id}")
            return response
            
        except Exception as e:
            logger.error(f"Error processing user message: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _process_message_by_state(self, conversation: Dict, user_message: str) -> Dict[str, Any]:
        """Process message based on current conversation state"""
        
        current_state = conversation['state']
        
        if current_state == self.CONVERSATION_STATES['awaiting_request']:
            return self._handle_command_request(conversation, user_message)
        
        elif current_state == self.CONVERSATION_STATES['initial']:
            # Handle initial state as a command request - user is ready to give commands
            conversation['state'] = self.CONVERSATION_STATES['awaiting_request']
            return self._handle_command_request(conversation, user_message)
        
        elif current_state == self.CONVERSATION_STATES['script_validated']:
            return self._handle_validation_response(conversation, user_message)
        
        elif current_state == self.CONVERSATION_STATES['awaiting_approval']:
            return self._handle_approval_response(conversation, user_message)
        
        else:
            return self._handle_general_message(conversation, user_message)
    
    def _handle_command_request(self, conversation: Dict, user_message: str) -> Dict[str, Any]:
        """Handle initial command request from user"""
        try:
            logger.info(f"Generating script for request: {user_message}")
            
            # Generate script using AI
            generation_result = self.command_generator.generate_script_from_request(
                user_message, 
                conversation.get('selected_hosts', [])
            )
            
            if not generation_result.get('success'):
                return {
                    'success': False,
                    'error': f"Failed to generate script: {generation_result.get('error', 'Unknown error')}"
                }
            
            # Validate the generated script
            validation_result = self.command_validator.validate_script(
                generation_result['script']
            )
            
            # Store results in conversation
            conversation['current_script'] = generation_result
            conversation['validation_result'] = validation_result
            conversation['state'] = self.CONVERSATION_STATES['script_validated']
            
            # Create response message
            response_content = self._create_script_validation_response(
                generation_result, validation_result
            )
            
            bot_message = {
                'id': str(uuid.uuid4()),
                'type': 'bot',
                'content': response_content['text'],
                'timestamp': datetime.now().isoformat(),
                'metadata': {
                    'conversation_state': 'script_validated',
                    'script_data': generation_result,
                    'validation_data': validation_result,
                    'available_actions': response_content['actions']
                }
            }
            
            return {
                'success': True,
                'message': bot_message,
                'conversation_state': conversation['state'],
                'script_data': generation_result,
                'validation_data': validation_result
            }
            
        except Exception as e:
            logger.error(f"Error handling command request: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _handle_validation_response(self, conversation: Dict, user_message: str) -> Dict[str, Any]:
        """Handle user response to script validation"""
        
        user_choice = user_message.lower().strip()
        
        if user_choice in ['run', 'execute', 'yes', 'proceed']:
            return self._execute_script(conversation)
        
        elif user_choice in ['edit', 'modify', 'change']:
            return self._handle_edit_request(conversation)
        
        elif user_choice in ['try again', 'regenerate', 'new', 'different']:
            return self._handle_regenerate_request(conversation)
        
        else:
            # Provide guidance on available options
            bot_message = {
                'id': str(uuid.uuid4()),
                'type': 'bot',
                'content': "I didn't understand your choice. Please choose one of the following options:\n\n" +
                          "Just type your choice or click one of the buttons.",
                'timestamp': datetime.now().isoformat(),
                'metadata': {
                    'conversation_state': 'script_validated',
                    'available_actions': ['run', 'edit', 'try_again']
                }
            }
            
            return {
                'success': True,
                'message': bot_message,
                'conversation_state': conversation['state']
            }
    
    def _execute_script(self, conversation: Dict) -> Dict[str, Any]:
        """Execute the script with version checking and AI analysis"""
        try:
            script_data = conversation.get('current_script')
            validation_data = conversation.get('validation_result')
            selected_hosts = conversation.get('selected_hosts', [])
            
            if not script_data or not validation_data:
                return {
                    'success': False,
                    'error': 'No script or validation data available'
                }
            
            if not selected_hosts:
                return {
                    'success': False,
                    'error': 'No hosts selected for execution'
                }
            
            # Get chatbot settings for version checking
            settings = self._get_chatbot_settings()
            min_version = settings.get('minimum_agent_version', '1.6.0')
            version_check_enabled = settings.get('require_version_check', True)
            
            conversation['state'] = self.CONVERSATION_STATES['executing']
            
            # Start execution with version checking and AI analysis
            execution_id = str(uuid.uuid4())
            execution_thread = threading.Thread(
                target=self._execute_with_version_check_and_analysis,
                args=(conversation['id'], execution_id, script_data['script'], selected_hosts, min_version, version_check_enabled)
            )
            execution_thread.daemon = True
            execution_thread.start()
            
            bot_message = {
                'id': str(uuid.uuid4()),
                'type': 'bot',
                'content': f"🚀 **Executing script with version checking...**

" +
                          f"**Step 1:** Checking agent versions (minimum required: {min_version})
" +
                          f"**Step 2:** Executing script on compatible hosts
" +
                          f"**Step 3:** Analyzing results with AI

" +
                          f"This process may take a few moments...",
                'timestamp': datetime.now().isoformat(),
                'metadata': {
                    'conversation_state': 'executing',
                    'execution_id': execution_id,
                    'available_actions': []
                }
            }
            
            return {
                'success': True,
                'message': bot_message,
                'conversation_state': conversation['state'],
                'execution_id': execution_id
            }
            
        except Exception as e:
            logger.error(f"Error executing script: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    def _execute_with_version_check_and_analysis(self, conversation_id: str, execution_id: str, script: str, selected_hosts: List[Dict], min_version: str, version_check_enabled: bool):
        """Execute script with version checking and AI analysis"""
        try:
            conversation = self.active_conversations.get(conversation_id)
            if not conversation:
                return
            
            logger.info(f"Starting enhanced execution {execution_id} on {len(selected_hosts)} hosts")
            
            execution_results = {
                'execution_id': execution_id,
                'started_at': datetime.now().isoformat(),
                'completed_at': None,
                'status': 'running',
                'version_checks': {},
                'results': {},
                'ai_analysis': None,
                'summary': {
                    'total_hosts': len(selected_hosts),
                    'version_compatible': 0,
                    'version_incompatible': 0,
                    'successful': 0,
                    'failed': 0,
                    'errors': []
                }
            }
            
            # Step 1: Check agent versions
            compatible_hosts = []
            incompatible_hosts = []
            
            for host in selected_hosts:
                host_id = host.get('id')
                host_name = host.get('name', 'Unknown')
                
                if version_check_enabled:
                    # Check agent version
                    version = self._check_agent_version(host_id)
                    execution_results['version_checks'][host_name] = {
                        'version': version,
                        'compatible': self._is_version_compatible(version, min_version)
                    }
                    
                    if self._is_version_compatible(version, min_version):
                        compatible_hosts.append(host)
                        execution_results['summary']['version_compatible'] += 1
                    else:
                        incompatible_hosts.append(host)
                        execution_results['summary']['version_incompatible'] += 1
                        logger.warning(f"Host {host_name} has incompatible version {version}, minimum required: {min_version}")
                else:
                    # Skip version checking
                    compatible_hosts.append(host)
                    execution_results['version_checks'][host_name] = {
                        'version': 'Not checked',
                        'compatible': True
                    }
                    execution_results['summary']['version_compatible'] += 1
            
            # Step 2: Execute script on compatible hosts
            script_outputs = {}
            
            for host in compatible_hosts:
                try:
                    host_id = host.get('id')
                    host_name = host.get('name', 'Unknown')
                    
                    logger.info(f"Executing script on host {host_name}")
                    
                    # Execute the script (this should use your existing script execution logic)
                    result = self._execute_script_on_single_host(host_id, script)
                    
                    if result.get('success'):
                        execution_results['results'][host_name] = {
                            'status': 'success',
                            'stdout': result.get('stdout', ''),
                            'stderr': result.get('stderr', ''),
                            'exit_code': result.get('exit_code', 0),
                            'execution_time': result.get('execution_time', 0)
                        }
                        script_outputs[host_name] = result.get('stdout', '')
                        execution_results['summary']['successful'] += 1
                    else:
                        execution_results['results'][host_name] = {
                            'status': 'failed',
                            'error': result.get('error', 'Unknown error'),
                            'stderr': result.get('stderr', ''),
                            'exit_code': result.get('exit_code', 1)
                        }
                        execution_results['summary']['failed'] += 1
                        execution_results['summary']['errors'].append(f"{host_name}: {result.get('error', 'Unknown error')}")
                        
                except Exception as e:
                    logger.error(f"Error executing on host {host_name}: {e}")
                    execution_results['results'][host_name] = {
                        'status': 'failed',
                        'error': str(e),
                        'exit_code': 1
                    }
                    execution_results['summary']['failed'] += 1
                    execution_results['summary']['errors'].append(f"{host_name}: {str(e)}")
            
            # Step 3: AI Analysis of results
            if script_outputs:
                try:
                    ai_analysis = self._analyze_script_output_with_ai(script_outputs, script)
                    execution_results['ai_analysis'] = ai_analysis
                except Exception as e:
                    logger.error(f"Error in AI analysis: {e}")
                    execution_results['ai_analysis'] = {
                        'error': f"AI analysis failed: {str(e)}"
                    }
            
            # Complete execution
            execution_results['completed_at'] = datetime.now().isoformat()
            execution_results['status'] = 'completed'
            
            # Store results
            conversation['execution_results'] = execution_results
            conversation['state'] = self.CONVERSATION_STATES['completed']
            
            # Send completion message with AI analysis
            self._send_execution_completion_message(conversation_id, execution_results)
            
            logger.info(f"Enhanced execution {execution_id} completed")
            
        except Exception as e:
            logger.error(f"Error in enhanced execution: {e}")
            # Send error message
            if conversation_id in self.active_conversations:
                conversation = self.active_conversations[conversation_id]
                conversation['state'] = self.CONVERSATION_STATES['error']
    def _execute_script_on_hosts(self, conversation_id: str, execution_id: str, script: str, selected_hosts: List[Dict]):
        """Execute script on selected hosts (runs in background thread)"""
        try:
            conversation = self.active_conversations.get(conversation_id)
            if not conversation:
                return
            
            logger.info(f"Starting script execution {execution_id} on {len(selected_hosts)} hosts")
            
            execution_results = {
                'execution_id': execution_id,
                'started_at': datetime.now().isoformat(),
                'completed_at': None,
                'status': 'running',
                'results': {},
                'summary': {
                    'total_hosts': len(selected_hosts),
                    'successful': 0,
                    'failed': 0,
                    'errors': []
                }
            }
            
            # Execute on each host
            for host in selected_hosts:
                try:
                    host_id = host.get('id')
                    host_name = host.get('name', 'Unknown')
                    
                    logger.info(f"Executing script on host {host_name}")
                    
                    # Execute command via host manager
                    result, error = self.host_manager.execute_command(host, script, timeout=300)
                    
                    if result and result.get('success'):
                        execution_results['results'][host_id] = {
                            'host_name': host_name,
                            'host_ip': host.get('ip_address', 'Unknown'),
                            'status': 'success',
                            'stdout': result.get('stdout', ''),
                            'stderr': result.get('stderr', ''),
                            'exit_code': result.get('exit_code', 0),
                            'execution_time': result.get('execution_time', 'Unknown')
                        }
                        execution_results['summary']['successful'] += 1
                    else:
                        error_msg = result.get('stderr', error) if result else str(error)
                        execution_results['results'][host_id] = {
                            'host_name': host_name,
                            'host_ip': host.get('ip_address', 'Unknown'),
                            'status': 'failed',
                            'error': error_msg,
                            'stdout': result.get('stdout', '') if result else '',
                            'stderr': result.get('stderr', '') if result else ''
                        }
                        execution_results['summary']['failed'] += 1
                        execution_results['summary']['errors'].append(f"{host_name}: {error_msg}")
                        
                except Exception as e:
                    logger.error(f"Error executing on host {host.get('name', 'Unknown')}: {e}")
                    execution_results['results'][host.get('id', 'unknown')] = {
                        'host_name': host.get('name', 'Unknown'),
                        'host_ip': host.get('ip_address', 'Unknown'),
                        'status': 'error',
                        'error': str(e)
                    }
                    execution_results['summary']['failed'] += 1
                    execution_results['summary']['errors'].append(f"{host.get('name', 'Unknown')}: {str(e)}")
            
            # Mark execution as completed
            execution_results['completed_at'] = datetime.now().isoformat()
            execution_results['status'] = 'completed'
            
            # Store results in conversation
            conversation['execution_results'] = execution_results
            conversation['state'] = self.CONVERSATION_STATES['completed']
            conversation['updated_at'] = datetime.now().isoformat()
            
            # Create completion message
            completion_message = self._create_execution_completion_message(execution_results)
            conversation['messages'].append(completion_message)
            
            # Save conversation
            self._save_conversation(conversation)
            
            logger.info(f"Script execution {execution_id} completed")
            
        except Exception as e:
            logger.error(f"Error in background execution: {e}")
            # Handle execution failure
            if conversation:
                conversation['state'] = self.CONVERSATION_STATES['error']
                error_message = {
                    'id': str(uuid.uuid4()),
                    'type': 'bot',
                    'content': f"❌ **Execution Failed**\n\nAn error occurred during script execution: {str(e)}",
                    'timestamp': datetime.now().isoformat(),
                    'metadata': {
                        'conversation_state': 'error',
                        'error': str(e)
                    }
                }
                conversation['messages'].append(error_message)
                self._save_conversation(conversation)
    
    def _create_execution_completion_message(self, execution_results: Dict) -> Dict[str, Any]:
        """Create message for execution completion"""
        
        summary = execution_results['summary']
        success_rate = (summary['successful'] / summary['total_hosts']) * 100 if summary['total_hosts'] > 0 else 0
        
        # Determine overall status icon and color
        if summary['successful'] == summary['total_hosts']:
            status_icon = "✅"
            status_text = "**All executions completed successfully!**"
        elif summary['successful'] > 0:
            status_icon = "⚠️"
            status_text = f"**Partial success** - {summary['successful']}/{summary['total_hosts']} hosts succeeded"
        else:
            status_icon = "❌"
            status_text = "**All executions failed**"
        
        content = f"{status_icon} {status_text}\n\n"
        content += f"**Execution Summary:**\n"
        content += f"• Total hosts: {summary['total_hosts']}\n"
        content += f"• Successful: {summary['successful']}\n"
        content += f"• Failed: {summary['failed']}\n"
        content += f"• Success rate: {success_rate:.1f}%\n\n"
        
        if summary['successful'] > 0:
            content += "**Successful Results:**\n"
            for host_id, result in execution_results['results'].items():
                if result['status'] == 'success':
                    content += f"• **{result['host_name']}** ({result['host_ip']}): ✓ Success\n"
        
        if summary['errors']:
            content += "\n**Errors:**\n"
            for error in summary['errors'][:3]:  # Show first 3 errors
                content += f"• {error}\n"
            if len(summary['errors']) > 3:
                content += f"• ... and {len(summary['errors']) - 3} more errors\n"
        
        content += f"\n*Execution completed at {execution_results['completed_at']}*"
        
        return {
            'id': str(uuid.uuid4()),
            'type': 'bot',
            'content': content,
            'timestamp': datetime.now().isoformat(),
            'metadata': {
                'conversation_state': 'completed',
                'execution_results': execution_results,
                'available_actions': ['new_request', 'view_details']
            }
        }
    
    def get_execution_results(self, conversation_id: str, execution_id: str) -> Dict[str, Any]:
        """Get detailed execution results"""
        try:
            conversation = self.active_conversations.get(conversation_id)
            if not conversation:
                return {'success': False, 'error': 'Conversation not found'}
            
            execution_results = conversation.get('execution_results')
            if not execution_results or execution_results.get('execution_id') != execution_id:
                return {'success': False, 'error': 'Execution results not found'}
            
            return {
                'success': True,
                'execution_results': execution_results
            }
            
        except Exception as e:
            logger.error(f"Error getting execution results: {e}")
            return {'success': False, 'error': str(e)}
    
    def _create_script_validation_response(self, script_data: Dict, validation_data: Dict) -> Dict[str, Any]:
        """Create response showing script and validation results"""
        
        safety_info = self.command_validator.get_safety_explanation(validation_data['overall_risk'])
        
        content = f"I've generated a script for your request: **{script_data['user_request']}**\n\n"
        
        # Show script preview
        content += "**Generated Script:**\n```bash\n"
        content += script_data['script']
        content += "\n```\n\n"
        
        # Show explanation
        content += "**What this script does:**\n"
        content += script_data['explanation'] + "\n\n"
        
        # Show safety assessment
        content += f"**Safety Assessment:** {safety_info['icon']} {safety_info['title']}\n"
        content += safety_info['description'] + "\n\n"
        
        if validation_data.get('warnings'):
            content += "**Warnings:**\n"
            for warning in validation_data['warnings'][:3]:
                content += f"• {warning['description']}\n"
            content += "\n"
        
        if validation_data.get('risks'):
            content += "**⚠️ Risks Identified:**\n"
            for risk in validation_data['risks']:
                content += f"• {risk['description']}\n"
            content += "\n"
        
        # Show estimated runtime
        content += f"**Estimated runtime:** {script_data.get('estimated_runtime', 'Unknown')}\n\n"
        
        # Show available actions
        
        return {
            'text': content,
            'actions': available_actions
        }
    
    def _get_welcome_message(self) -> str:
        """Get the welcome message for new conversations"""
        return """👋 **Welcome to the NetworkMap AI Assistant!**

I can help you run commands on your remote hosts by generating and executing bash scripts. Just describe what you'd like to do, and I'll:

1. **Generate** a safe bash script based on your request
2. **Validate** the script for security and safety  
3. **Show you** exactly what will be executed
4. **Run it** on your selected hosts with your approval

**Example requests:**
• "Check disk space on all servers"
• "Show me the memory usage"
• "List running processes"
• "Get network interface information"

**To get started:**
1. Select the hosts you want to work with (if any)
2. Type your request below

What would you like me to help you with today?"""
    
    def _handle_edit_request(self, conversation: Dict) -> Dict[str, Any]:
        """Handle request to edit the generated script"""
        # This would integrate with the script editor functionality
        bot_message = {
            'id': str(uuid.uuid4()),
            'type': 'bot',
            'content': "**Script Editor**\n\nI'll open the script editor where you can modify the generated script. " +
                      "The editor will show the current script and allow you to make changes, " +
                      "then re-validate it for safety.\n\n" +
                      "*[Script editor interface would appear here]*",
            'timestamp': datetime.now().isoformat(),
            'metadata': {
                'conversation_state': 'editing',
                'available_actions': ['save_edit', 'cancel_edit']
            }
        }
        
        return {
            'success': True,
            'message': bot_message,
            'conversation_state': 'editing'
        }
    
    def _handle_regenerate_request(self, conversation: Dict) -> Dict[str, Any]:
        """Handle request to generate a new script"""
        conversation['state'] = self.CONVERSATION_STATES['awaiting_request']
        
        bot_message = {
            'id': str(uuid.uuid4()),
            'type': 'bot',
            'content': "I'll generate a new script for you. Please describe what you'd like to do, " +
                      "and I can try a different approach or focus on specific aspects of your request.\n\n" +
                      "What would you like the new script to do?",
            'timestamp': datetime.now().isoformat(),
            'metadata': {
                'conversation_state': 'awaiting_request',
                'available_actions': ['new_request']
            }
        }
        
        return {
            'success': True,
            'message': bot_message,
            'conversation_state': conversation['state']
        }
    
    def _handle_approval_response(self, conversation: Dict, user_message: str) -> Dict[str, Any]:
        """Handle user response to approval request"""
        user_choice = user_message.lower().strip()
        
        if user_choice in ['yes', 'approve', 'proceed', 'confirm']:
            # Override approval and execute
            if conversation.get('validation_result'):
                conversation['validation_result']['is_approved'] = True
            return self._execute_script(conversation)
        
        else:
            # User declined - go back to validation state
            conversation['state'] = self.CONVERSATION_STATES['script_validated']
            
            bot_message = {
                'id': str(uuid.uuid4()),
                'type': 'bot',
                'content': "Execution cancelled. You can still:\n\n" +
                'timestamp': datetime.now().isoformat(),
                'metadata': {
                    'conversation_state': 'script_validated',
                    'available_actions': ['edit', 'try_again']
                }
            }
            
            return {
                'success': True,
                'message': bot_message,
                'conversation_state': conversation['state']
            }
    
    def _handle_general_message(self, conversation: Dict, user_message: str) -> Dict[str, Any]:
        """Handle general messages not tied to specific states"""
        
        bot_message = {
            'id': str(uuid.uuid4()),
            'type': 'bot',
            'content': "I'm here to help you run commands on your remote hosts. " +
                      "Please describe what you'd like me to do, and I'll generate a script for you.\n\n" +
                      "For example:\n" +
                      "• \"Check disk usage on all servers\"\n" +
                      "• \"Show me running processes\"\n" +
                      "• \"Get system information\"",
            'timestamp': datetime.now().isoformat(),
            'metadata': {
                'conversation_state': conversation['state'],
                'available_actions': ['new_request']
            }
        }
        
        return {
            'success': True,
            'message': bot_message,
            'conversation_state': conversation['state']
        }
    
    def _save_conversation(self, conversation: Dict):
        """Save conversation to database"""
        try:
            self.db.save_chatbot_conversation(conversation)
            logger.info(f"Saved conversation {conversation['id']} to database")
            
        except Exception as e:
            logger.error(f"Error saving conversation: {e}")
    
    def get_conversation(self, conversation_id: str) -> Optional[Dict[str, Any]]:
        """Get conversation by ID"""
        return self.active_conversations.get(conversation_id)
    
    def get_conversation_history(self, conversation_id: str) -> Dict[str, Any]:
        """Get conversation message history"""
        try:
            conversation = self.active_conversations.get(conversation_id)
            if not conversation:
                return {'success': False, 'error': 'Conversation not found'}
            
            return {
                'success': True,
                'conversation_id': conversation_id,
                'messages': conversation['messages'],
                'state': conversation['state'],
                'updated_at': conversation['updated_at']
            }
            
        except Exception as e:
            logger.error(f"Error getting conversation history: {e}")
            return {'success': False, 'error': str(e)}


    def _get_chatbot_settings(self):
        """Get current chatbot settings"""
        try:
            from database import get_chatbot_settings
            return get_chatbot_settings()
        except Exception as e:
            logger.error(f"Error getting chatbot settings: {e}")
            return {
                'minimum_agent_version': '1.6.0',
                'require_version_check': True,
                'script_timeout': 300,
                'max_concurrent_executions': 5
            }
    
    def _check_agent_version(self, host_id: str) -> str:
        """Check the agent version on a specific host"""
        try:
            from database import execute_script_on_host
            
            # Execute version check command
            version_script = """
            # Try multiple methods to get agent version
            if [ -f '/opt/networkmap-agent/version.txt' ]; then
                cat /opt/networkmap-agent/version.txt
            elif command -v networkmap-agent >/dev/null 2>&1; then
                networkmap-agent --version 2>/dev/null || echo "unknown"
            elif [ -f '/usr/local/bin/networkmap-agent' ]; then
                /usr/local/bin/networkmap-agent --version 2>/dev/null || echo "unknown"
            else
                echo "unknown"
            fi
            """
            
            result = execute_script_on_host(host_id, version_script.strip())
            if result and result.get('success') and result.get('stdout'):
                version = result.get('stdout', '').strip()
                return version if version else 'unknown'
            else:
                return 'unknown'
                
        except Exception as e:
            logger.error(f"Error checking agent version for host {host_id}: {e}")
            return 'unknown'
    
    def _is_version_compatible(self, version: str, min_version: str) -> bool:
        """Check if version meets minimum requirement"""
        try:
            if version == 'unknown':
                return False
            
            # Simple version comparison (assumes semantic versioning)
            def version_tuple(v):
                return tuple(map(int, (v.split("."))))
            
            return version_tuple(version) >= version_tuple(min_version)
        except Exception as e:
            logger.error(f"Error comparing versions {version} vs {min_version}: {e}")
            return False
    
    def _execute_script_on_single_host(self, host_id: str, script: str) -> dict:
        """Execute script on a single host and return detailed results"""
        try:
            from database import execute_script_on_host
            import time
            
            start_time = time.time()
            result = execute_script_on_host(host_id, script)
            end_time = time.time()
            
            if result:
                result['execution_time'] = end_time - start_time
                return result
            else:
                return {
                    'success': False,
                    'error': 'No result returned from host',
                    'execution_time': end_time - start_time
                }
                
        except Exception as e:
            logger.error(f"Error executing script on host {host_id}: {e}")
            return {
                'success': False,
                'error': str(e),
                'execution_time': 0
            }
    def _analyze_script_output_with_ai(self, script_outputs: dict, original_script: str) -> dict:
        """Analyze script output using AI to provide insights"""
        try:
            from ai_command_generator import AICommandGenerator
            
            # Combine all outputs for analysis
            combined_output = f"**Script Executed:**\n{original_script}\n\n**Outputs from Hosts:**\n"
            
            for host_name, output in script_outputs.items():
                combined_output += f"\n**Host: {host_name}**\n{output}\n"
            
            # Create analysis prompt
            analysis_prompt = f"""Analyze the following script execution results and provide a structured analysis with these sections:

1. **Summary**: Brief overview of what was executed and overall results
2. **Data**: Key data points and metrics extracted from the output  
3. **Troubleshooting**: Any issues, errors, or warnings identified
4. **Observations**: Notable patterns, trends, or insights
5. **Next Steps**: Recommended actions or follow-up tasks

Here are the results:

{combined_output}

Please format your response in markdown with clear sections."""
            
            # Get AI analysis
            ai_generator = AICommandGenerator()
            ai_response = ai_generator.generate_command(analysis_prompt)
            
            if ai_response.get('success') and ai_response.get('script'):
                return {
                    'analysis_text': ai_response.get('script'),
                    'success': True
                }
            else:
                return {
                    'error': 'Failed to generate AI analysis',
                    'success': False
                }
                
        except Exception as e:
            logger.error(f"Error in AI analysis: {e}")
            return {
                'error': str(e),
                'success': False
            }
    
    def _send_execution_completion_message(self, conversation_id: str, execution_results: dict):
        """Send completion message with results and AI analysis"""
        try:
            conversation = self.active_conversations.get(conversation_id)
            if not conversation:
                return
            
            # Build completion message with structured results
            summary = execution_results.get('summary', {})
            ai_analysis = execution_results.get('ai_analysis', {})
            
            content = f"""✅ **Script Execution Complete!**

**📊 Summary:**
• Total hosts: {summary.get('total_hosts', 0)}
• Compatible hosts: {summary.get('version_compatible', 0)}  
• Incompatible hosts: {summary.get('version_incompatible', 0)}
• Successful: {summary.get('successful', 0)}
• Failed: {summary.get('failed', 0)}

---

**🤖 AI Analysis:**

{ai_analysis.get('analysis_text', 'AI analysis not available') if ai_analysis.get('success') else f"AI analysis failed: {ai_analysis.get('error', 'Unknown error')}"}"""
            
            # Store the message for retrieval
            bot_message = {
                'id': str(uuid.uuid4()),
                'type': 'bot', 
                'content': content,
                'timestamp': datetime.now().isoformat(),
                'metadata': {
                    'conversation_state': 'completed',
                    'execution_results': execution_results
                }
            }
            
            conversation['messages'].append(bot_message)
            logger.info(f"Completion message added to conversation {conversation_id}")
            
        except Exception as e:
            logger.error(f"Error sending completion message: {e}")
if __name__ == "__main__":
    # Basic test
    print("Chatbot Controller module loaded successfully")
